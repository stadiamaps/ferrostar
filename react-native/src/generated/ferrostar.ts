// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFutureFree,
  type UniffiCallbackInterfaceFree,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceRouteDeviationDetector,
  type UniffiVTableCallbackInterfaceRouteRequestGenerator,
  type UniffiVTableCallbackInterfaceRouteResponseParser,
} from './ferrostar-ffi';
import {
  type FfiConverter,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UniffiTimestamp,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterArrayBuffer,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterTimestamp,
  FfiConverterUInt16,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  rustCall,
  rustCallWithError,
  uniffiCreateCallStatus,
  uniffiCreateRecord,
  uniffiTraitInterfaceCall,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Returns the next simulation state based on the desired strategy.
 * Results of this can be thought of like a stream from a generator function.
 *
 * This function is intended to be called once/second.
 * However, the caller may vary speed to purposefully replay at a faster rate
 * (ex: calling 3x per second will be a triple speed simulation).
 *
 * When there are now more locations to visit, returns the same state forever.
 */
export function advanceLocationSimulation(
  state: LocationSimulationState
): LocationSimulationState {
  return FfiConverterTypeLocationSimulationState.lift(
    rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_advance_location_simulation(
          FfiConverterTypeLocationSimulationState.lower(state),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function createFerrostarLogger(): void {
  rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().uniffi_ferrostar_fn_func_create_ferrostar_logger(
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Creates a [`RouteResponseParser`] capable of parsing OSRM responses.
 *
 * This response parser is designed to be fairly flexible,
 * supporting both vanilla OSRM and enhanced Valhalla (ex: from Stadia Maps and Mapbox) outputs
 * which contain richer information like banners and voice instructions for navigation.
 */
export function createOsrmResponseParser(
  polylinePrecision: /*u32*/ number
): RouteResponseParser {
  return FfiConverterTypeRouteResponseParser.lift(
    rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_create_osrm_response_parser(
          FfiConverterUInt32.lower(polylinePrecision),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a [`Route`] from OSRM data.
 *
 * This uses the same logic as the [`OsrmResponseParser`] and is designed to be fairly flexible,
 * supporting both vanilla OSRM and enhanced Valhalla (ex: from Stadia Maps and Mapbox) outputs
 * which contain richer information like banners and voice instructions for navigation.
 */
export function createRouteFromOsrm(
  routeData: ArrayBuffer,
  waypointData: ArrayBuffer,
  polylinePrecision: /*u32*/ number
): Route /*throws*/ {
  return FfiConverterTypeRoute.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeParsingError.lift.bind(
        FfiConverterTypeParsingError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_create_route_from_osrm(
          FfiConverterArrayBuffer.lower(routeData),
          FfiConverterArrayBuffer.lower(waypointData),
          FfiConverterUInt32.lower(polylinePrecision),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a [`RouteRequestGenerator`]
 * which generates requests to an arbitrary Valhalla server (using the OSRM response format).
 *
 * This is provided as a convenience for use from foreign code when creating your own [`routing_adapters::RouteAdapter`].
 */
export function createValhallaRequestGenerator(
  endpointUrl: string,
  profile: string,
  optionsJson: string | undefined
): RouteRequestGenerator /*throws*/ {
  return FfiConverterTypeRouteRequestGenerator.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeInstantiationError.lift.bind(
        FfiConverterTypeInstantiationError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_create_valhalla_request_generator(
          FfiConverterString.lower(endpointUrl),
          FfiConverterString.lower(profile),
          FfiConverterOptionalString.lower(optionsJson),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Helper function for getting the route as an encoded polyline.
 *
 * Mostly used for debugging.
 */
export function getRoutePolyline(
  route: Route,
  precision: /*u32*/ number
): string /*throws*/ {
  return FfiConverterString.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeModelError.lift.bind(
        FfiConverterTypeModelError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_get_route_polyline(
          FfiConverterTypeRoute.lower(route),
          FfiConverterUInt32.lower(precision),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a location simulation from a set of coordinates.
 *
 * Optionally resamples the input line so that there is a maximum distance between points.
 */
export function locationSimulationFromCoordinates(
  coordinates: Array<GeographicCoordinate>,
  resampleDistance: /*f64*/ number | undefined,
  bias: LocationBias
): LocationSimulationState /*throws*/ {
  return FfiConverterTypeLocationSimulationState.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeSimulationError.lift.bind(
        FfiConverterTypeSimulationError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_location_simulation_from_coordinates(
          FfiConverterArrayTypeGeographicCoordinate.lower(coordinates),
          FfiConverterOptionalFloat64.lower(resampleDistance),
          FfiConverterTypeLocationBias.lower(bias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a location simulation from a polyline.
 *
 * Optionally resamples the input line so that there is no more than the specified maximum distance between points.
 */
export function locationSimulationFromPolyline(
  polyline: string,
  precision: /*u32*/ number,
  resampleDistance: /*f64*/ number | undefined,
  bias: LocationBias
): LocationSimulationState /*throws*/ {
  return FfiConverterTypeLocationSimulationState.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeSimulationError.lift.bind(
        FfiConverterTypeSimulationError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_location_simulation_from_polyline(
          FfiConverterString.lower(polyline),
          FfiConverterUInt32.lower(precision),
          FfiConverterOptionalFloat64.lower(resampleDistance),
          FfiConverterTypeLocationBias.lower(bias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a location simulation from a route.
 *
 * Optionally resamples the route geometry so that there is no more than the specified maximum distance between points.
 */
export function locationSimulationFromRoute(
  route: Route,
  resampleDistance: /*f64*/ number | undefined,
  bias: LocationBias
): LocationSimulationState /*throws*/ {
  return FfiConverterTypeLocationSimulationState.lift(
    rustCallWithError(
      /*liftError:*/ FfiConverterTypeSimulationError.lift.bind(
        FfiConverterTypeSimulationError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_func_location_simulation_from_route(
          FfiConverterTypeRoute.lower(route),
          FfiConverterOptionalFloat64.lower(resampleDistance),
          FfiConverterTypeLocationBias.lower(bias),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

/**
 * A geographic bounding box defined by its corners.
 */
export type BoundingBox = {
  /**
   * The southwest corner of the bounding box.
   */
  sw: GeographicCoordinate;
  /**
   * The northeast corner of the bounding box.
   */
  ne: GeographicCoordinate;
};

/**
 * Generated factory for {@link BoundingBox} record objects.
 */
export const BoundingBox = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<BoundingBox, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BoundingBox}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BoundingBox}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<BoundingBox>,
  });
})();

const FfiConverterTypeBoundingBox = (() => {
  type TypeName = BoundingBox;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        sw: FfiConverterTypeGeographicCoordinate.read(from),
        ne: FfiConverterTypeGeographicCoordinate.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeGeographicCoordinate.write(value.sw, into);
      FfiConverterTypeGeographicCoordinate.write(value.ne, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeGeographicCoordinate.allocationSize(value.sw) +
        FfiConverterTypeGeographicCoordinate.allocationSize(value.ne)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Details about congestion for an incident.
 */
export type Congestion = {
  /**
   * The level of congestion caused by the incident.
   *
   * 0 = no congestion
   *
   * 100 = road closed
   *
   * Other values mean no congestion was calculated
   */
  value: /*u8*/ number;
};

/**
 * Generated factory for {@link Congestion} record objects.
 */
export const Congestion = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Congestion, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Congestion}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Congestion}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Congestion>,
  });
})();

const FfiConverterTypeCongestion = (() => {
  type TypeName = Congestion;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        value: FfiConverterUInt8.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt8.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterUInt8.allocationSize(value.value);
    }
  }
  return new FFIConverter();
})();

/**
 * The direction in which the user/device is observed to be traveling.
 */
export type CourseOverGround = {
  /**
   * The direction in which the user's device is traveling, measured in clockwise degrees from
   * true north (N = 0, E = 90, S = 180, W = 270).
   */
  degrees: /*u16*/ number;
  /**
   * The accuracy of the course value, measured in degrees.
   */
  accuracy: /*u16*/ number | undefined;
};

/**
 * Generated factory for {@link CourseOverGround} record objects.
 */
export const CourseOverGround = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CourseOverGround, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CourseOverGround}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CourseOverGround}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CourseOverGround>,
  });
})();

const FfiConverterTypeCourseOverGround = (() => {
  type TypeName = CourseOverGround;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        degrees: FfiConverterUInt16.read(from),
        accuracy: FfiConverterOptionalUInt16.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt16.write(value.degrees, into);
      FfiConverterOptionalUInt16.write(value.accuracy, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt16.allocationSize(value.degrees) +
        FfiConverterOptionalUInt16.allocationSize(value.accuracy)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A geographic coordinate in WGS84.
 */
export type GeographicCoordinate = {
  /**
   * The latitude (in degrees).
   */
  lat: /*f64*/ number;
  /**
   * The Longitude (in degrees).
   */
  lng: /*f64*/ number;
};

/**
 * Generated factory for {@link GeographicCoordinate} record objects.
 */
export const GeographicCoordinate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      GeographicCoordinate,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link GeographicCoordinate}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link GeographicCoordinate}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<GeographicCoordinate>,
  });
})();

const FfiConverterTypeGeographicCoordinate = (() => {
  type TypeName = GeographicCoordinate;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lat: FfiConverterFloat64.read(from),
        lng: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.lat, into);
      FfiConverterFloat64.write(value.lng, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.lat) +
        FfiConverterFloat64.allocationSize(value.lng)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The heading of the user/device.
 */
export type Heading = {
  /**
   * The heading in degrees relative to true north.
   */
  trueHeading: /*u16*/ number;
  /**
   * The platform specific accuracy of the heading value.
   */
  accuracy: /*u16*/ number;
  /**
   * The time at which the heading was recorded.
   */
  timestamp: UniffiTimestamp;
};

/**
 * Generated factory for {@link Heading} record objects.
 */
export const Heading = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Heading, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Heading}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Heading}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Heading>,
  });
})();

const FfiConverterTypeHeading = (() => {
  type TypeName = Heading;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        trueHeading: FfiConverterUInt16.read(from),
        accuracy: FfiConverterUInt16.read(from),
        timestamp: FfiConverterTimestamp.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt16.write(value.trueHeading, into);
      FfiConverterUInt16.write(value.accuracy, into);
      FfiConverterTimestamp.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt16.allocationSize(value.trueHeading) +
        FfiConverterUInt16.allocationSize(value.accuracy) +
        FfiConverterTimestamp.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An incident affecting the free flow of traffic,
 * such as constructions, accidents, and congestion.
 */
export type Incident = {
  /**
   * A unique identifier for the incident.
   */
  id: string;
  /**
   * The type of incident.
   */
  incidentType: IncidentType;
  /**
   * A short description of the incident.
   */
  description: string | undefined;
  /**
   * A longer description of the incident.
   */
  longDescription: string | undefined;
  /**
   * The time at which the incident was *last* created.
   *
   * NB: This can change throughout the life of the incident.
   */
  creationTime: UtcDateTime | undefined;
  /**
   * The time at which the incident started or is expected to start (ex: planned closure).
   */
  startTime: UtcDateTime | undefined;
  /**
   * The time at which the incident ended or is expected to end.
   */
  endTime: UtcDateTime | undefined;
  /**
   * The level of impact to traffic.
   */
  impact: Impact | undefined;
  /**
   * Lanes which are blocked by the incident.
   */
  lanesBlocked: Array<BlockedLane>;
  /**
   * Info about the amount of congestion on the road around the incident.
   */
  congestion: Congestion | undefined;
  /**
   * Is the road completely closed?
   */
  closed: boolean | undefined;
  /**
   * The index into the [`RouteStep`] geometry where the incident starts.
   */
  geometryIndexStart: /*u64*/ bigint;
  /**
   * The index into the [`RouteStep`] geometry where the incident ends.
   */
  geometryIndexEnd: /*u64*/ bigint | undefined;
  /**
   * Optional additional information about the type of incident (free-form text).
   */
  subType: string | undefined;
  /**
   * Optional descriptions about the type of incident (free-form text).
   */
  subTypeDescription: string | undefined;
  /**
   * The ISO 3166-1 alpha-2 code of the country in which the incident occurs.
   */
  iso31661Alpha2: string | undefined;
  /**
   * The ISO 3166-1 alpha-3 code of the country in which the incident occurs.
   */
  iso31661Alpha3: string | undefined;
  /**
   * A list of road names affected by the incident.
   */
  affectedRoadNames: Array<string>;
  /**
   * The bounding box over which the incident occurs.
   */
  bbox: BoundingBox | undefined;
};

/**
 * Generated factory for {@link Incident} record objects.
 */
export const Incident = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Incident, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Incident}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Incident}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Incident>,
  });
})();

const FfiConverterTypeIncident = (() => {
  type TypeName = Incident;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        incidentType: FfiConverterTypeIncidentType.read(from),
        description: FfiConverterOptionalString.read(from),
        longDescription: FfiConverterOptionalString.read(from),
        creationTime: FfiConverterOptionalTypeUtcDateTime.read(from),
        startTime: FfiConverterOptionalTypeUtcDateTime.read(from),
        endTime: FfiConverterOptionalTypeUtcDateTime.read(from),
        impact: FfiConverterOptionalTypeImpact.read(from),
        lanesBlocked: FfiConverterArrayTypeBlockedLane.read(from),
        congestion: FfiConverterOptionalTypeCongestion.read(from),
        closed: FfiConverterOptionalBool.read(from),
        geometryIndexStart: FfiConverterUInt64.read(from),
        geometryIndexEnd: FfiConverterOptionalUInt64.read(from),
        subType: FfiConverterOptionalString.read(from),
        subTypeDescription: FfiConverterOptionalString.read(from),
        iso31661Alpha2: FfiConverterOptionalString.read(from),
        iso31661Alpha3: FfiConverterOptionalString.read(from),
        affectedRoadNames: FfiConverterArrayString.read(from),
        bbox: FfiConverterOptionalTypeBoundingBox.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterTypeIncidentType.write(value.incidentType, into);
      FfiConverterOptionalString.write(value.description, into);
      FfiConverterOptionalString.write(value.longDescription, into);
      FfiConverterOptionalTypeUtcDateTime.write(value.creationTime, into);
      FfiConverterOptionalTypeUtcDateTime.write(value.startTime, into);
      FfiConverterOptionalTypeUtcDateTime.write(value.endTime, into);
      FfiConverterOptionalTypeImpact.write(value.impact, into);
      FfiConverterArrayTypeBlockedLane.write(value.lanesBlocked, into);
      FfiConverterOptionalTypeCongestion.write(value.congestion, into);
      FfiConverterOptionalBool.write(value.closed, into);
      FfiConverterUInt64.write(value.geometryIndexStart, into);
      FfiConverterOptionalUInt64.write(value.geometryIndexEnd, into);
      FfiConverterOptionalString.write(value.subType, into);
      FfiConverterOptionalString.write(value.subTypeDescription, into);
      FfiConverterOptionalString.write(value.iso31661Alpha2, into);
      FfiConverterOptionalString.write(value.iso31661Alpha3, into);
      FfiConverterArrayString.write(value.affectedRoadNames, into);
      FfiConverterOptionalTypeBoundingBox.write(value.bbox, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterTypeIncidentType.allocationSize(value.incidentType) +
        FfiConverterOptionalString.allocationSize(value.description) +
        FfiConverterOptionalString.allocationSize(value.longDescription) +
        FfiConverterOptionalTypeUtcDateTime.allocationSize(value.creationTime) +
        FfiConverterOptionalTypeUtcDateTime.allocationSize(value.startTime) +
        FfiConverterOptionalTypeUtcDateTime.allocationSize(value.endTime) +
        FfiConverterOptionalTypeImpact.allocationSize(value.impact) +
        FfiConverterArrayTypeBlockedLane.allocationSize(value.lanesBlocked) +
        FfiConverterOptionalTypeCongestion.allocationSize(value.congestion) +
        FfiConverterOptionalBool.allocationSize(value.closed) +
        FfiConverterUInt64.allocationSize(value.geometryIndexStart) +
        FfiConverterOptionalUInt64.allocationSize(value.geometryIndexEnd) +
        FfiConverterOptionalString.allocationSize(value.subType) +
        FfiConverterOptionalString.allocationSize(value.subTypeDescription) +
        FfiConverterOptionalString.allocationSize(value.iso31661Alpha2) +
        FfiConverterOptionalString.allocationSize(value.iso31661Alpha3) +
        FfiConverterArrayString.allocationSize(value.affectedRoadNames) +
        FfiConverterOptionalTypeBoundingBox.allocationSize(value.bbox)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The content of a visual instruction.
 */
export type LaneInfo = {
  active: boolean;
  directions: Array<string>;
  activeDirection: string | undefined;
};

/**
 * Generated factory for {@link LaneInfo} record objects.
 */
export const LaneInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LaneInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LaneInfo}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LaneInfo}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LaneInfo>,
  });
})();

const FfiConverterTypeLaneInfo = (() => {
  type TypeName = LaneInfo;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        active: FfiConverterBool.read(from),
        directions: FfiConverterArrayString.read(from),
        activeDirection: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.active, into);
      FfiConverterArrayString.write(value.directions, into);
      FfiConverterOptionalString.write(value.activeDirection, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.active) +
        FfiConverterArrayString.allocationSize(value.directions) +
        FfiConverterOptionalString.allocationSize(value.activeDirection)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The current state of the simulation.
 */
export type LocationSimulationState = {
  currentLocation: UserLocation;
  remainingLocations: Array<GeographicCoordinate>;
  bias: LocationBias;
};

/**
 * Generated factory for {@link LocationSimulationState} record objects.
 */
export const LocationSimulationState = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      LocationSimulationState,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LocationSimulationState}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LocationSimulationState}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<LocationSimulationState>,
  });
})();

const FfiConverterTypeLocationSimulationState = (() => {
  type TypeName = LocationSimulationState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        currentLocation: FfiConverterTypeUserLocation.read(from),
        remainingLocations:
          FfiConverterArrayTypeGeographicCoordinate.read(from),
        bias: FfiConverterTypeLocationBias.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeUserLocation.write(value.currentLocation, into);
      FfiConverterArrayTypeGeographicCoordinate.write(
        value.remainingLocations,
        into
      );
      FfiConverterTypeLocationBias.write(value.bias, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeUserLocation.allocationSize(value.currentLocation) +
        FfiConverterArrayTypeGeographicCoordinate.allocationSize(
          value.remainingLocations
        ) +
        FfiConverterTypeLocationBias.allocationSize(value.bias)
      );
    }
  }
  return new FFIConverter();
})();

export type NavigationControllerConfig = {
  /**
   * Configures when navigation advances to the next step in the route.
   */
  stepAdvance: StepAdvanceMode;
  /**
   * Configures when the user is deemed to be off course.
   *
   * NOTE: This is distinct from the action that is taken.
   * It is only the determination that the user has deviated from the expected route.
   */
  routeDeviationTracking: RouteDeviationTracking;
  /**
   * Configures how the heading component of the snapped location is reported in [`TripState`].
   */
  snappedLocationCourseFiltering: CourseFiltering;
};

/**
 * Generated factory for {@link NavigationControllerConfig} record objects.
 */
export const NavigationControllerConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      NavigationControllerConfig,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link NavigationControllerConfig}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link NavigationControllerConfig}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<NavigationControllerConfig>,
  });
})();

const FfiConverterTypeNavigationControllerConfig = (() => {
  type TypeName = NavigationControllerConfig;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        stepAdvance: FfiConverterTypeStepAdvanceMode.read(from),
        routeDeviationTracking:
          FfiConverterTypeRouteDeviationTracking.read(from),
        snappedLocationCourseFiltering:
          FfiConverterTypeCourseFiltering.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeStepAdvanceMode.write(value.stepAdvance, into);
      FfiConverterTypeRouteDeviationTracking.write(
        value.routeDeviationTracking,
        into
      );
      FfiConverterTypeCourseFiltering.write(
        value.snappedLocationCourseFiltering,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeStepAdvanceMode.allocationSize(value.stepAdvance) +
        FfiConverterTypeRouteDeviationTracking.allocationSize(
          value.routeDeviationTracking
        ) +
        FfiConverterTypeCourseFiltering.allocationSize(
          value.snappedLocationCourseFiltering
        )
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Information describing the series of steps needed to travel between two or more points.
 *
 * NOTE: This type is unstable and is still under active development and should be
 * considered unstable.
 */
export type Route = {
  geometry: Array<GeographicCoordinate>;
  bbox: BoundingBox;
  /**
   * The total route distance, in meters.
   */
  distance: /*f64*/ number;
  /**
   * The ordered list of waypoints to visit, including the starting point.
   * Note that this is distinct from the *geometry* which includes all points visited.
   * A waypoint represents a start/end point for a route leg.
   */
  waypoints: Array<Waypoint>;
  steps: Array<RouteStep>;
};

/**
 * Generated factory for {@link Route} record objects.
 */
export const Route = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Route, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Route}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Route}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Route>,
  });
})();

const FfiConverterTypeRoute = (() => {
  type TypeName = Route;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        geometry: FfiConverterArrayTypeGeographicCoordinate.read(from),
        bbox: FfiConverterTypeBoundingBox.read(from),
        distance: FfiConverterFloat64.read(from),
        waypoints: FfiConverterArrayTypeWaypoint.read(from),
        steps: FfiConverterArrayTypeRouteStep.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeGeographicCoordinate.write(value.geometry, into);
      FfiConverterTypeBoundingBox.write(value.bbox, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterArrayTypeWaypoint.write(value.waypoints, into);
      FfiConverterArrayTypeRouteStep.write(value.steps, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeGeographicCoordinate.allocationSize(
          value.geometry
        ) +
        FfiConverterTypeBoundingBox.allocationSize(value.bbox) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterArrayTypeWaypoint.allocationSize(value.waypoints) +
        FfiConverterArrayTypeRouteStep.allocationSize(value.steps)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A maneuver (such as a turn or merge) followed by travel of a certain distance until reaching
 * the next step.
 */
export type RouteStep = {
  /**
   * The full route geometry for this step.
   */
  geometry: Array<GeographicCoordinate>;
  /**
   * The distance, in meters, to travel along the route after the maneuver to reach the next step.
   */
  distance: /*f64*/ number;
  /**
   * The estimated duration, in seconds, that it will take to complete this step.
   */
  duration: /*f64*/ number;
  /**
   * The name of the road being traveled on (useful for certain UI styles).
   */
  roadName: string | undefined;
  /**
   * A list of exits (name or number).
   */
  exits: Array<string>;
  /**
   * A description of the maneuver (ex: "Turn wright onto main street").
   *
   * Note for UI implementers: the context this appears in (or doesn't)
   * depends somewhat on your use case and routing engine.
   * For example, this field is useful as a written instruction in Valhalla.
   */
  instruction: string;
  /**
   * A list of instructions for visual display (usually as banners) at specific points along the step.
   */
  visualInstructions: Array<VisualInstruction>;
  /**
   * A list of prompts to announce (via speech synthesis) at specific points along the step.
   */
  spokenInstructions: Array<SpokenInstruction>;
  /**
   * A list of json encoded strings representing annotations between each coordinate along the step.
   */
  annotations: Array<string> | undefined;
  /**
   * A list of incidents that occur along the step.
   */
  incidents: Array<Incident>;
};

/**
 * Generated factory for {@link RouteStep} record objects.
 */
export const RouteStep = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<RouteStep, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link RouteStep}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link RouteStep}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<RouteStep>,
  });
})();

const FfiConverterTypeRouteStep = (() => {
  type TypeName = RouteStep;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        geometry: FfiConverterArrayTypeGeographicCoordinate.read(from),
        distance: FfiConverterFloat64.read(from),
        duration: FfiConverterFloat64.read(from),
        roadName: FfiConverterOptionalString.read(from),
        exits: FfiConverterArrayString.read(from),
        instruction: FfiConverterString.read(from),
        visualInstructions: FfiConverterArrayTypeVisualInstruction.read(from),
        spokenInstructions: FfiConverterArrayTypeSpokenInstruction.read(from),
        annotations: FfiConverterOptionalArrayString.read(from),
        incidents: FfiConverterArrayTypeIncident.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeGeographicCoordinate.write(value.geometry, into);
      FfiConverterFloat64.write(value.distance, into);
      FfiConverterFloat64.write(value.duration, into);
      FfiConverterOptionalString.write(value.roadName, into);
      FfiConverterArrayString.write(value.exits, into);
      FfiConverterString.write(value.instruction, into);
      FfiConverterArrayTypeVisualInstruction.write(
        value.visualInstructions,
        into
      );
      FfiConverterArrayTypeSpokenInstruction.write(
        value.spokenInstructions,
        into
      );
      FfiConverterOptionalArrayString.write(value.annotations, into);
      FfiConverterArrayTypeIncident.write(value.incidents, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeGeographicCoordinate.allocationSize(
          value.geometry
        ) +
        FfiConverterFloat64.allocationSize(value.distance) +
        FfiConverterFloat64.allocationSize(value.duration) +
        FfiConverterOptionalString.allocationSize(value.roadName) +
        FfiConverterArrayString.allocationSize(value.exits) +
        FfiConverterString.allocationSize(value.instruction) +
        FfiConverterArrayTypeVisualInstruction.allocationSize(
          value.visualInstructions
        ) +
        FfiConverterArrayTypeSpokenInstruction.allocationSize(
          value.spokenInstructions
        ) +
        FfiConverterOptionalArrayString.allocationSize(value.annotations) +
        FfiConverterArrayTypeIncident.allocationSize(value.incidents)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The speed of the user from the location provider.
 */
export type Speed = {
  /**
   * The user's speed in meters per second.
   */
  value: /*f64*/ number;
  /**
   * The accuracy of the speed value, measured in meters per second.
   */
  accuracy: /*f64*/ number | undefined;
};

/**
 * Generated factory for {@link Speed} record objects.
 */
export const Speed = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Speed, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Speed}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Speed}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Speed>,
  });
})();

const FfiConverterTypeSpeed = (() => {
  type TypeName = Speed;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        value: FfiConverterFloat64.read(from),
        accuracy: FfiConverterOptionalFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.value, into);
      FfiConverterOptionalFloat64.write(value.accuracy, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.value) +
        FfiConverterOptionalFloat64.allocationSize(value.accuracy)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An instruction that can be synthesized using a TTS engine to announce an upcoming maneuver.
 *
 * Note that these do not have any locale information attached.
 */
export type SpokenInstruction = {
  /**
   * Plain-text instruction which can be synthesized with a TTS engine.
   */
  text: string;
  /**
   * Speech Synthesis Markup Language, which should be preferred by clients capable of understanding it.
   */
  ssml: string | undefined;
  /**
   * How far (in meters) from the upcoming maneuver the instruction should start being displayed
   */
  triggerDistanceBeforeManeuver: /*f64*/ number;
  /**
   * A unique identifier for this instruction.
   *
   * This is provided so that platform-layer integrations can easily disambiguate between distinct utterances,
   * which may have the same textual content.
   * UUIDs conveniently fill this purpose.
   *
   * NOTE: While it is possible to deterministically create UUIDs, we do not do so at this time.
   * This should be theoretically possible though if someone cares to write up a proposal and a PR.
   */
  utteranceId: Uuid;
};

/**
 * Generated factory for {@link SpokenInstruction} record objects.
 */
export const SpokenInstruction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SpokenInstruction, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SpokenInstruction}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SpokenInstruction}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SpokenInstruction>,
  });
})();

const FfiConverterTypeSpokenInstruction = (() => {
  type TypeName = SpokenInstruction;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        text: FfiConverterString.read(from),
        ssml: FfiConverterOptionalString.read(from),
        triggerDistanceBeforeManeuver: FfiConverterFloat64.read(from),
        utteranceId: FfiConverterTypeUuid.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.text, into);
      FfiConverterOptionalString.write(value.ssml, into);
      FfiConverterFloat64.write(value.triggerDistanceBeforeManeuver, into);
      FfiConverterTypeUuid.write(value.utteranceId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.text) +
        FfiConverterOptionalString.allocationSize(value.ssml) +
        FfiConverterFloat64.allocationSize(
          value.triggerDistanceBeforeManeuver
        ) +
        FfiConverterTypeUuid.allocationSize(value.utteranceId)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * High-level state describing progress through a route.
 */
export type TripProgress = {
  /**
   * The distance to the next maneuver, in meters.
   */
  distanceToNextManeuver: /*f64*/ number;
  /**
   * The total distance remaining in the trip, in meters.
   *
   * This is the sum of the distance remaining in the current step and the distance remaining in all subsequent steps.
   */
  distanceRemaining: /*f64*/ number;
  /**
   * The total duration remaining in the trip, in seconds.
   */
  durationRemaining: /*f64*/ number;
};

/**
 * Generated factory for {@link TripProgress} record objects.
 */
export const TripProgress = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TripProgress, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TripProgress}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TripProgress}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TripProgress>,
  });
})();

const FfiConverterTypeTripProgress = (() => {
  type TypeName = TripProgress;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        distanceToNextManeuver: FfiConverterFloat64.read(from),
        distanceRemaining: FfiConverterFloat64.read(from),
        durationRemaining: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterFloat64.write(value.distanceToNextManeuver, into);
      FfiConverterFloat64.write(value.distanceRemaining, into);
      FfiConverterFloat64.write(value.durationRemaining, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterFloat64.allocationSize(value.distanceToNextManeuver) +
        FfiConverterFloat64.allocationSize(value.distanceRemaining) +
        FfiConverterFloat64.allocationSize(value.durationRemaining)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The location of the user that is navigating.
 *
 * In addition to coordinates, this includes estimated accuracy and course information,
 * which can influence navigation logic and UI.
 *
 * NOTE: Heading is absent on purpose.
 * Heading updates are not related to a change in the user's location.
 */
export type UserLocation = {
  coordinates: GeographicCoordinate;
  /**
   * The estimated accuracy of the coordinate (in meters)
   */
  horizontalAccuracy: /*f64*/ number;
  courseOverGround: CourseOverGround | undefined;
  timestamp: UniffiTimestamp;
  speed: Speed | undefined;
};

/**
 * Generated factory for {@link UserLocation} record objects.
 */
export const UserLocation = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UserLocation, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UserLocation}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UserLocation}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UserLocation>,
  });
})();

const FfiConverterTypeUserLocation = (() => {
  type TypeName = UserLocation;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coordinates: FfiConverterTypeGeographicCoordinate.read(from),
        horizontalAccuracy: FfiConverterFloat64.read(from),
        courseOverGround: FfiConverterOptionalTypeCourseOverGround.read(from),
        timestamp: FfiConverterTimestamp.read(from),
        speed: FfiConverterOptionalTypeSpeed.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeGeographicCoordinate.write(value.coordinates, into);
      FfiConverterFloat64.write(value.horizontalAccuracy, into);
      FfiConverterOptionalTypeCourseOverGround.write(
        value.courseOverGround,
        into
      );
      FfiConverterTimestamp.write(value.timestamp, into);
      FfiConverterOptionalTypeSpeed.write(value.speed, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeGeographicCoordinate.allocationSize(value.coordinates) +
        FfiConverterFloat64.allocationSize(value.horizontalAccuracy) +
        FfiConverterOptionalTypeCourseOverGround.allocationSize(
          value.courseOverGround
        ) +
        FfiConverterTimestamp.allocationSize(value.timestamp) +
        FfiConverterOptionalTypeSpeed.allocationSize(value.speed)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * An instruction for visual display (usually as banners) at a specific point along a [`RouteStep`].
 */
export type VisualInstruction = {
  /**
   * The primary instruction content.
   *
   * This is usually given more visual weight.
   */
  primaryContent: VisualInstructionContent;
  /**
   * Optional secondary instruction content.
   */
  secondaryContent: VisualInstructionContent | undefined;
  /**
   * Optional sub-maneuver instruction content.
   */
  subContent: VisualInstructionContent | undefined;
  /**
   * How far (in meters) from the upcoming maneuver the instruction should start being displayed
   */
  triggerDistanceBeforeManeuver: /*f64*/ number;
};

/**
 * Generated factory for {@link VisualInstruction} record objects.
 */
export const VisualInstruction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VisualInstruction, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VisualInstruction}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VisualInstruction}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VisualInstruction>,
  });
})();

const FfiConverterTypeVisualInstruction = (() => {
  type TypeName = VisualInstruction;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        primaryContent: FfiConverterTypeVisualInstructionContent.read(from),
        secondaryContent:
          FfiConverterOptionalTypeVisualInstructionContent.read(from),
        subContent: FfiConverterOptionalTypeVisualInstructionContent.read(from),
        triggerDistanceBeforeManeuver: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeVisualInstructionContent.write(
        value.primaryContent,
        into
      );
      FfiConverterOptionalTypeVisualInstructionContent.write(
        value.secondaryContent,
        into
      );
      FfiConverterOptionalTypeVisualInstructionContent.write(
        value.subContent,
        into
      );
      FfiConverterFloat64.write(value.triggerDistanceBeforeManeuver, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeVisualInstructionContent.allocationSize(
          value.primaryContent
        ) +
        FfiConverterOptionalTypeVisualInstructionContent.allocationSize(
          value.secondaryContent
        ) +
        FfiConverterOptionalTypeVisualInstructionContent.allocationSize(
          value.subContent
        ) +
        FfiConverterFloat64.allocationSize(value.triggerDistanceBeforeManeuver)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * The content of a visual instruction.
 */
export type VisualInstructionContent = {
  /**
   * The text to display.
   */
  text: string;
  /**
   * A standardized maneuver type (if any).
   */
  maneuverType: ManeuverType | undefined;
  /**
   * A standardized maneuver modifier (if any).
   */
  maneuverModifier: ManeuverModifier | undefined;
  /**
   * If applicable, the number of degrees you need to go around the roundabout before exiting.
   *
   * For example, entering and exiting the roundabout in the same direction of travel
   * (as if you had gone straight, apart from the detour)
   * would be an exit angle of 180 degrees.
   */
  roundaboutExitDegrees: /*u16*/ number | undefined;
  /**
   * Detailed information about the lanes. This is typically only present in sub-maneuver instructions.
   */
  laneInfo: Array<LaneInfo> | undefined;
  /**
   * The exit number (or similar identifier like "8B").
   */
  exitNumbers: Array<string>;
};

/**
 * Generated factory for {@link VisualInstructionContent} record objects.
 */
export const VisualInstructionContent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      VisualInstructionContent,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VisualInstructionContent}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VisualInstructionContent}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VisualInstructionContent>,
  });
})();

const FfiConverterTypeVisualInstructionContent = (() => {
  type TypeName = VisualInstructionContent;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        text: FfiConverterString.read(from),
        maneuverType: FfiConverterOptionalTypeManeuverType.read(from),
        maneuverModifier: FfiConverterOptionalTypeManeuverModifier.read(from),
        roundaboutExitDegrees: FfiConverterOptionalUInt16.read(from),
        laneInfo: FfiConverterOptionalArrayTypeLaneInfo.read(from),
        exitNumbers: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.text, into);
      FfiConverterOptionalTypeManeuverType.write(value.maneuverType, into);
      FfiConverterOptionalTypeManeuverModifier.write(
        value.maneuverModifier,
        into
      );
      FfiConverterOptionalUInt16.write(value.roundaboutExitDegrees, into);
      FfiConverterOptionalArrayTypeLaneInfo.write(value.laneInfo, into);
      FfiConverterArrayString.write(value.exitNumbers, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.text) +
        FfiConverterOptionalTypeManeuverType.allocationSize(
          value.maneuverType
        ) +
        FfiConverterOptionalTypeManeuverModifier.allocationSize(
          value.maneuverModifier
        ) +
        FfiConverterOptionalUInt16.allocationSize(value.roundaboutExitDegrees) +
        FfiConverterOptionalArrayTypeLaneInfo.allocationSize(value.laneInfo) +
        FfiConverterArrayString.allocationSize(value.exitNumbers)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A waypoint along a route.
 *
 * Within the context of Ferrostar, a route request consists of exactly one [`UserLocation`]
 * and at least one [`Waypoint`]. The route starts from the user's location (which may
 * contain other useful information like their current course for the [`crate::routing_adapters::RouteRequestGenerator`]
 * to use) and proceeds through one or more waypoints.
 *
 * Waypoints are used during route calculation, are tracked throughout the lifecycle of a trip,
 * and are used for recalculating when the user deviates from the expected route.
 *
 * Note that support for properties beyond basic geographic coordinates varies by routing engine.
 */
export type Waypoint = {
  coordinate: GeographicCoordinate;
  kind: WaypointKind;
};

/**
 * Generated factory for {@link Waypoint} record objects.
 */
export const Waypoint = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Waypoint, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Waypoint}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Waypoint}, with defaults specified
     * in Rust, in the {@link ferrostar} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ferrostar} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Waypoint>,
  });
})();

const FfiConverterTypeWaypoint = (() => {
  type TypeName = Waypoint;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        coordinate: FfiConverterTypeGeographicCoordinate.read(from),
        kind: FfiConverterTypeWaypointKind.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeGeographicCoordinate.write(value.coordinate, into);
      FfiConverterTypeWaypointKind.write(value.kind, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeGeographicCoordinate.allocationSize(value.coordinate) +
        FfiConverterTypeWaypointKind.allocationSize(value.kind)
      );
    }
  }
  return new FFIConverter();
})();

const stringToArrayBuffer = (s: string): ArrayBuffer =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)
  );

const arrayBufferToString = (ab: ArrayBuffer): string =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__arraybuffer_to_string(
      ab,
      status
    )
  );

const stringByteLength = (s: string): number =>
  rustCall((status) =>
    nativeModule().uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)
  );

const FfiConverterString = (() => {
  const lengthConverter = FfiConverterInt32;
  type TypeName = string;
  class FFIConverter implements FfiConverter<ArrayBuffer, TypeName> {
    lift(value: ArrayBuffer): TypeName {
      return arrayBufferToString(value);
    }
    lower(value: TypeName): ArrayBuffer {
      return stringToArrayBuffer(value);
    }
    read(from: RustBuffer): TypeName {
      const length = lengthConverter.read(from);
      const bytes = from.readBytes(length);
      return arrayBufferToString(bytes);
    }
    write(value: TypeName, into: RustBuffer): void {
      const buffer = stringToArrayBuffer(value);
      const numBytes = buffer.byteLength;
      lengthConverter.write(numBytes, into);
      into.writeBytes(buffer);
    }
    allocationSize(value: TypeName): number {
      return lengthConverter.allocationSize(0) + stringByteLength(value);
    }
  }

  return new FFIConverter();
})();

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type UtcDateTime = /*i64*/ bigint;
// FfiConverter for UtcDateTime, a type alias for /*i64*/bigint.
const FfiConverterTypeUtcDateTime = FfiConverterInt64;

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type Uuid = string;
// FfiConverter for Uuid, a type alias for string.
const FfiConverterTypeUuid = FfiConverterString;

/**
 * The lane type blocked by the incident.
 */
export enum BlockedLane {
  Left,
  LeftCenter,
  LeftTurnLane,
  Center,
  Right,
  RightCenter,
  RightTurnLane,
  Hov,
}

const FfiConverterTypeBlockedLane = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = BlockedLane;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return BlockedLane.Left;
        case 2:
          return BlockedLane.LeftCenter;
        case 3:
          return BlockedLane.LeftTurnLane;
        case 4:
          return BlockedLane.Center;
        case 5:
          return BlockedLane.Right;
        case 6:
          return BlockedLane.RightCenter;
        case 7:
          return BlockedLane.RightTurnLane;
        case 8:
          return BlockedLane.Hov;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case BlockedLane.Left:
          return ordinalConverter.write(1, into);
        case BlockedLane.LeftCenter:
          return ordinalConverter.write(2, into);
        case BlockedLane.LeftTurnLane:
          return ordinalConverter.write(3, into);
        case BlockedLane.Center:
          return ordinalConverter.write(4, into);
        case BlockedLane.Right:
          return ordinalConverter.write(5, into);
        case BlockedLane.RightCenter:
          return ordinalConverter.write(6, into);
        case BlockedLane.RightTurnLane:
          return ordinalConverter.write(7, into);
        case BlockedLane.Hov:
          return ordinalConverter.write(8, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * Controls filtering/post-processing of user course by the [`NavigationController`].
 */
export enum CourseFiltering {
  /**
     * Snap the user's course to the current step's linestring using the next index in the step's geometry.

     */
  SnapToRoute,
  /**
   * Use the raw course as reported by the location provider with no processing.
   */
  Raw,
}

const FfiConverterTypeCourseFiltering = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CourseFiltering;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return CourseFiltering.SnapToRoute;
        case 2:
          return CourseFiltering.Raw;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case CourseFiltering.SnapToRoute:
          return ordinalConverter.write(1, into);
        case CourseFiltering.Raw:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The impact of the incident that has occurred.
 */
export enum Impact {
  Unknown,
  Critical,
  Major,
  Minor,
  Low,
}

const FfiConverterTypeImpact = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Impact;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Impact.Unknown;
        case 2:
          return Impact.Critical;
        case 3:
          return Impact.Major;
        case 4:
          return Impact.Minor;
        case 5:
          return Impact.Low;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Impact.Unknown:
          return ordinalConverter.write(1, into);
        case Impact.Critical:
          return ordinalConverter.write(2, into);
        case Impact.Major:
          return ordinalConverter.write(3, into);
        case Impact.Minor:
          return ordinalConverter.write(4, into);
        case Impact.Low:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The type of incident that has occurred.
 */
export enum IncidentType {
  Accident,
  Congestion,
  Construction,
  DisabledVehicle,
  LaneRestriction,
  MassTransit,
  Miscellaneous,
  OtherNews,
  PlannedEvent,
  RoadClosure,
  RoadHazard,
  Weather,
}

const FfiConverterTypeIncidentType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = IncidentType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return IncidentType.Accident;
        case 2:
          return IncidentType.Congestion;
        case 3:
          return IncidentType.Construction;
        case 4:
          return IncidentType.DisabledVehicle;
        case 5:
          return IncidentType.LaneRestriction;
        case 6:
          return IncidentType.MassTransit;
        case 7:
          return IncidentType.Miscellaneous;
        case 8:
          return IncidentType.OtherNews;
        case 9:
          return IncidentType.PlannedEvent;
        case 10:
          return IncidentType.RoadClosure;
        case 11:
          return IncidentType.RoadHazard;
        case 12:
          return IncidentType.Weather;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case IncidentType.Accident:
          return ordinalConverter.write(1, into);
        case IncidentType.Congestion:
          return ordinalConverter.write(2, into);
        case IncidentType.Construction:
          return ordinalConverter.write(3, into);
        case IncidentType.DisabledVehicle:
          return ordinalConverter.write(4, into);
        case IncidentType.LaneRestriction:
          return ordinalConverter.write(5, into);
        case IncidentType.MassTransit:
          return ordinalConverter.write(6, into);
        case IncidentType.Miscellaneous:
          return ordinalConverter.write(7, into);
        case IncidentType.OtherNews:
          return ordinalConverter.write(8, into);
        case IncidentType.PlannedEvent:
          return ordinalConverter.write(9, into);
        case IncidentType.RoadClosure:
          return ordinalConverter.write(10, into);
        case IncidentType.RoadHazard:
          return ordinalConverter.write(11, into);
        case IncidentType.Weather:
          return ordinalConverter.write(12, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: InstantiationError

// Enum: InstantiationError
export enum InstantiationError_Tags {
  OptionsJsonParseError = 'OptionsJsonParseError',
}
export const InstantiationError = (() => {
  type OptionsJsonParseError__interface = {
    tag: InstantiationError_Tags.OptionsJsonParseError;
  };

  class OptionsJsonParseError_
    extends UniffiError
    implements OptionsJsonParseError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'InstantiationError';
    readonly tag = InstantiationError_Tags.OptionsJsonParseError;
    constructor() {
      super('InstantiationError', 'OptionsJsonParseError');
    }

    static new(): OptionsJsonParseError_ {
      return new OptionsJsonParseError_();
    }

    static instanceOf(obj: any): obj is OptionsJsonParseError_ {
      return obj.tag === InstantiationError_Tags.OptionsJsonParseError;
    }

    static hasInner(obj: any): obj is OptionsJsonParseError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is InstantiationError {
    return obj[uniffiTypeNameSymbol] === 'InstantiationError';
  }

  return Object.freeze({
    instanceOf,
    OptionsJsonParseError: OptionsJsonParseError_,
  });
})();

export type InstantiationError = InstanceType<
  (typeof InstantiationError)[keyof Omit<
    typeof InstantiationError,
    'instanceOf'
  >]
>;

// FfiConverter for enum InstantiationError
const FfiConverterTypeInstantiationError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = InstantiationError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new InstantiationError.OptionsJsonParseError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case InstantiationError_Tags.OptionsJsonParseError: {
          ordinalConverter.write(1, into);
          return;
        }
        default:
          // Throwing from here means that InstantiationError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case InstantiationError_Tags.OptionsJsonParseError: {
          return ordinalConverter.allocationSize(1);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: LocationBias
export enum LocationBias_Tags {
  Left = 'Left',
  Right = 'Right',
  Random = 'Random',
  None = 'None',
}
/**
 * Controls how simulated locations deviate from the actual route line.
 * This simulates real-world GPS behavior where readings often have systematic bias.
 */
export const LocationBias = (() => {
  type Left__interface = {
    tag: LocationBias_Tags.Left;
    inner: Readonly<[/*f64*/ number]>;
  };

  /**
   * Simulates GPS bias by offsetting locations to the left of the route direction.
   * The f64 parameter specifies the offset distance in meters.
   */
  class Left_ extends UniffiEnum implements Left__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LocationBias';
    readonly tag = LocationBias_Tags.Left;
    readonly inner: Readonly<[/*f64*/ number]>;
    constructor(v0: /*f64*/ number) {
      super('LocationBias', 'Left');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*f64*/ number): Left_ {
      return new Left_(v0);
    }

    static instanceOf(obj: any): obj is Left_ {
      return obj.tag === LocationBias_Tags.Left;
    }
  }

  type Right__interface = {
    tag: LocationBias_Tags.Right;
    inner: Readonly<[/*f64*/ number]>;
  };

  /**
   * Simulates GPS bias by offsetting locations to the right of the route direction.
   * The f64 parameter specifies the offset distance in meters.
   */
  class Right_ extends UniffiEnum implements Right__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LocationBias';
    readonly tag = LocationBias_Tags.Right;
    readonly inner: Readonly<[/*f64*/ number]>;
    constructor(v0: /*f64*/ number) {
      super('LocationBias', 'Right');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*f64*/ number): Right_ {
      return new Right_(v0);
    }

    static instanceOf(obj: any): obj is Right_ {
      return obj.tag === LocationBias_Tags.Right;
    }
  }

  type Random__interface = {
    tag: LocationBias_Tags.Random;
    inner: Readonly<[/*f64*/ number]>;
  };

  /**
   * Simulates GPS bias by randomly choosing left or right offset on initialization
   * and maintaining that bias throughout the route.
   * The f64 parameter specifies the offset distance in meters.
   *
   * This mimics real-world GPS behavior where bias direction is random but typically
   * remains consistent during a trip.
   */
  class Random_ extends UniffiEnum implements Random__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LocationBias';
    readonly tag = LocationBias_Tags.Random;
    readonly inner: Readonly<[/*f64*/ number]>;
    constructor(v0: /*f64*/ number) {
      super('LocationBias', 'Random');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*f64*/ number): Random_ {
      return new Random_(v0);
    }

    static instanceOf(obj: any): obj is Random_ {
      return obj.tag === LocationBias_Tags.Random;
    }
  }

  type None__interface = {
    tag: LocationBias_Tags.None;
  };

  /**
   * No position bias - locations follow the route line exactly.
   *
   * This provides "perfect" GPS behavior, useful for testing basic route following
   * without position uncertainty.
   */
  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LocationBias';
    readonly tag = LocationBias_Tags.None;
    constructor() {
      super('LocationBias', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === LocationBias_Tags.None;
    }
  }

  function instanceOf(obj: any): obj is LocationBias {
    return obj[uniffiTypeNameSymbol] === 'LocationBias';
  }

  return Object.freeze({
    instanceOf,
    Left: Left_,
    Right: Right_,
    Random: Random_,
    None: None_,
  });
})();

/**
 * Controls how simulated locations deviate from the actual route line.
 * This simulates real-world GPS behavior where readings often have systematic bias.
 */

export type LocationBias = InstanceType<
  (typeof LocationBias)[keyof Omit<typeof LocationBias, 'instanceOf'>]
>;

// FfiConverter for enum LocationBias
const FfiConverterTypeLocationBias = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LocationBias;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LocationBias.Left(FfiConverterFloat64.read(from));
        case 2:
          return new LocationBias.Right(FfiConverterFloat64.read(from));
        case 3:
          return new LocationBias.Random(FfiConverterFloat64.read(from));
        case 4:
          return new LocationBias.None();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LocationBias_Tags.Left: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner[0], into);
          return;
        }
        case LocationBias_Tags.Right: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner[0], into);
          return;
        }
        case LocationBias_Tags.Random: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner[0], into);
          return;
        }
        case LocationBias_Tags.None: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that LocationBias_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LocationBias_Tags.Left: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterFloat64.allocationSize(inner[0]);
          return size;
        }
        case LocationBias_Tags.Right: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterFloat64.allocationSize(inner[0]);
          return size;
        }
        case LocationBias_Tags.Random: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterFloat64.allocationSize(inner[0]);
          return size;
        }
        case LocationBias_Tags.None: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Additional information to further specify a [`ManeuverType`].
 */
export enum ManeuverModifier {
  UTurn,
  SharpRight,
  Right,
  SlightRight,
  Straight,
  SlightLeft,
  Left,
  SharpLeft,
}

const FfiConverterTypeManeuverModifier = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ManeuverModifier;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ManeuverModifier.UTurn;
        case 2:
          return ManeuverModifier.SharpRight;
        case 3:
          return ManeuverModifier.Right;
        case 4:
          return ManeuverModifier.SlightRight;
        case 5:
          return ManeuverModifier.Straight;
        case 6:
          return ManeuverModifier.SlightLeft;
        case 7:
          return ManeuverModifier.Left;
        case 8:
          return ManeuverModifier.SharpLeft;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ManeuverModifier.UTurn:
          return ordinalConverter.write(1, into);
        case ManeuverModifier.SharpRight:
          return ordinalConverter.write(2, into);
        case ManeuverModifier.Right:
          return ordinalConverter.write(3, into);
        case ManeuverModifier.SlightRight:
          return ordinalConverter.write(4, into);
        case ManeuverModifier.Straight:
          return ordinalConverter.write(5, into);
        case ManeuverModifier.SlightLeft:
          return ordinalConverter.write(6, into);
        case ManeuverModifier.Left:
          return ordinalConverter.write(7, into);
        case ManeuverModifier.SharpLeft:
          return ordinalConverter.write(8, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The broad class of maneuver to perform.
 *
 * This is usually combined with [`ManeuverModifier`] in [`VisualInstructionContent`].
 */
export enum ManeuverType {
  Turn,
  NewName,
  Depart,
  Arrive,
  Merge,
  OnRamp,
  OffRamp,
  Fork,
  EndOfRoad,
  Continue,
  Roundabout,
  Rotary,
  RoundaboutTurn,
  Notification,
  ExitRoundabout,
  ExitRotary,
}

const FfiConverterTypeManeuverType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ManeuverType;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ManeuverType.Turn;
        case 2:
          return ManeuverType.NewName;
        case 3:
          return ManeuverType.Depart;
        case 4:
          return ManeuverType.Arrive;
        case 5:
          return ManeuverType.Merge;
        case 6:
          return ManeuverType.OnRamp;
        case 7:
          return ManeuverType.OffRamp;
        case 8:
          return ManeuverType.Fork;
        case 9:
          return ManeuverType.EndOfRoad;
        case 10:
          return ManeuverType.Continue;
        case 11:
          return ManeuverType.Roundabout;
        case 12:
          return ManeuverType.Rotary;
        case 13:
          return ManeuverType.RoundaboutTurn;
        case 14:
          return ManeuverType.Notification;
        case 15:
          return ManeuverType.ExitRoundabout;
        case 16:
          return ManeuverType.ExitRotary;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ManeuverType.Turn:
          return ordinalConverter.write(1, into);
        case ManeuverType.NewName:
          return ordinalConverter.write(2, into);
        case ManeuverType.Depart:
          return ordinalConverter.write(3, into);
        case ManeuverType.Arrive:
          return ordinalConverter.write(4, into);
        case ManeuverType.Merge:
          return ordinalConverter.write(5, into);
        case ManeuverType.OnRamp:
          return ordinalConverter.write(6, into);
        case ManeuverType.OffRamp:
          return ordinalConverter.write(7, into);
        case ManeuverType.Fork:
          return ordinalConverter.write(8, into);
        case ManeuverType.EndOfRoad:
          return ordinalConverter.write(9, into);
        case ManeuverType.Continue:
          return ordinalConverter.write(10, into);
        case ManeuverType.Roundabout:
          return ordinalConverter.write(11, into);
        case ManeuverType.Rotary:
          return ordinalConverter.write(12, into);
        case ManeuverType.RoundaboutTurn:
          return ordinalConverter.write(13, into);
        case ManeuverType.Notification:
          return ordinalConverter.write(14, into);
        case ManeuverType.ExitRoundabout:
          return ordinalConverter.write(15, into);
        case ManeuverType.ExitRotary:
          return ordinalConverter.write(16, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Error type: ModelError

// Enum: ModelError
export enum ModelError_Tags {
  PolylineGenerationError = 'PolylineGenerationError',
}
export const ModelError = (() => {
  type PolylineGenerationError__interface = {
    tag: ModelError_Tags.PolylineGenerationError;
    inner: Readonly<{ error: string }>;
  };

  class PolylineGenerationError_
    extends UniffiError
    implements PolylineGenerationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ModelError';
    readonly tag = ModelError_Tags.PolylineGenerationError;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('ModelError', 'PolylineGenerationError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): PolylineGenerationError_ {
      return new PolylineGenerationError_(inner);
    }

    static instanceOf(obj: any): obj is PolylineGenerationError_ {
      return obj.tag === ModelError_Tags.PolylineGenerationError;
    }

    static hasInner(obj: any): obj is PolylineGenerationError_ {
      return PolylineGenerationError_.instanceOf(obj);
    }

    static getInner(
      obj: PolylineGenerationError_
    ): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ModelError {
    return obj[uniffiTypeNameSymbol] === 'ModelError';
  }

  return Object.freeze({
    instanceOf,
    PolylineGenerationError: PolylineGenerationError_,
  });
})();

export type ModelError = InstanceType<
  (typeof ModelError)[keyof Omit<typeof ModelError, 'instanceOf'>]
>;

// FfiConverter for enum ModelError
const FfiConverterTypeModelError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ModelError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ModelError.PolylineGenerationError({
            error: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ModelError_Tags.PolylineGenerationError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        default:
          // Throwing from here means that ModelError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ModelError_Tags.PolylineGenerationError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: ParsingError

// Enum: ParsingError
export enum ParsingError_Tags {
  InvalidRouteObject = 'InvalidRouteObject',
  InvalidGeometry = 'InvalidGeometry',
  MalformedAnnotations = 'MalformedAnnotations',
  InvalidStatusCode = 'InvalidStatusCode',
  UnknownParsingError = 'UnknownParsingError',
}
export const ParsingError = (() => {
  type InvalidRouteObject__interface = {
    tag: ParsingError_Tags.InvalidRouteObject;
    inner: Readonly<{ error: string }>;
  };

  class InvalidRouteObject_
    extends UniffiError
    implements InvalidRouteObject__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParsingError';
    readonly tag = ParsingError_Tags.InvalidRouteObject;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('ParsingError', 'InvalidRouteObject');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): InvalidRouteObject_ {
      return new InvalidRouteObject_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRouteObject_ {
      return obj.tag === ParsingError_Tags.InvalidRouteObject;
    }

    static hasInner(obj: any): obj is InvalidRouteObject_ {
      return InvalidRouteObject_.instanceOf(obj);
    }

    static getInner(obj: InvalidRouteObject_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type InvalidGeometry__interface = {
    tag: ParsingError_Tags.InvalidGeometry;
    inner: Readonly<{ error: string }>;
  };

  class InvalidGeometry_
    extends UniffiError
    implements InvalidGeometry__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParsingError';
    readonly tag = ParsingError_Tags.InvalidGeometry;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('ParsingError', 'InvalidGeometry');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): InvalidGeometry_ {
      return new InvalidGeometry_(inner);
    }

    static instanceOf(obj: any): obj is InvalidGeometry_ {
      return obj.tag === ParsingError_Tags.InvalidGeometry;
    }

    static hasInner(obj: any): obj is InvalidGeometry_ {
      return InvalidGeometry_.instanceOf(obj);
    }

    static getInner(obj: InvalidGeometry_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type MalformedAnnotations__interface = {
    tag: ParsingError_Tags.MalformedAnnotations;
    inner: Readonly<{ error: string }>;
  };

  class MalformedAnnotations_
    extends UniffiError
    implements MalformedAnnotations__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParsingError';
    readonly tag = ParsingError_Tags.MalformedAnnotations;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('ParsingError', 'MalformedAnnotations');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): MalformedAnnotations_ {
      return new MalformedAnnotations_(inner);
    }

    static instanceOf(obj: any): obj is MalformedAnnotations_ {
      return obj.tag === ParsingError_Tags.MalformedAnnotations;
    }

    static hasInner(obj: any): obj is MalformedAnnotations_ {
      return MalformedAnnotations_.instanceOf(obj);
    }

    static getInner(obj: MalformedAnnotations_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type InvalidStatusCode__interface = {
    tag: ParsingError_Tags.InvalidStatusCode;
    inner: Readonly<{ code: string }>;
  };

  class InvalidStatusCode_
    extends UniffiError
    implements InvalidStatusCode__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParsingError';
    readonly tag = ParsingError_Tags.InvalidStatusCode;
    readonly inner: Readonly<{ code: string }>;
    constructor(inner: { code: string }) {
      super('ParsingError', 'InvalidStatusCode');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { code: string }): InvalidStatusCode_ {
      return new InvalidStatusCode_(inner);
    }

    static instanceOf(obj: any): obj is InvalidStatusCode_ {
      return obj.tag === ParsingError_Tags.InvalidStatusCode;
    }

    static hasInner(obj: any): obj is InvalidStatusCode_ {
      return InvalidStatusCode_.instanceOf(obj);
    }

    static getInner(obj: InvalidStatusCode_): Readonly<{ code: string }> {
      return obj.inner;
    }
  }

  type UnknownParsingError__interface = {
    tag: ParsingError_Tags.UnknownParsingError;
  };

  class UnknownParsingError_
    extends UniffiError
    implements UnknownParsingError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ParsingError';
    readonly tag = ParsingError_Tags.UnknownParsingError;
    constructor() {
      super('ParsingError', 'UnknownParsingError');
    }

    static new(): UnknownParsingError_ {
      return new UnknownParsingError_();
    }

    static instanceOf(obj: any): obj is UnknownParsingError_ {
      return obj.tag === ParsingError_Tags.UnknownParsingError;
    }

    static hasInner(obj: any): obj is UnknownParsingError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is ParsingError {
    return obj[uniffiTypeNameSymbol] === 'ParsingError';
  }

  return Object.freeze({
    instanceOf,
    InvalidRouteObject: InvalidRouteObject_,
    InvalidGeometry: InvalidGeometry_,
    MalformedAnnotations: MalformedAnnotations_,
    InvalidStatusCode: InvalidStatusCode_,
    UnknownParsingError: UnknownParsingError_,
  });
})();

export type ParsingError = InstanceType<
  (typeof ParsingError)[keyof Omit<typeof ParsingError, 'instanceOf'>]
>;

// FfiConverter for enum ParsingError
const FfiConverterTypeParsingError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ParsingError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ParsingError.InvalidRouteObject({
            error: FfiConverterString.read(from),
          });
        case 2:
          return new ParsingError.InvalidGeometry({
            error: FfiConverterString.read(from),
          });
        case 3:
          return new ParsingError.MalformedAnnotations({
            error: FfiConverterString.read(from),
          });
        case 4:
          return new ParsingError.InvalidStatusCode({
            code: FfiConverterString.read(from),
          });
        case 5:
          return new ParsingError.UnknownParsingError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ParsingError_Tags.InvalidRouteObject: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case ParsingError_Tags.InvalidGeometry: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case ParsingError_Tags.MalformedAnnotations: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case ParsingError_Tags.InvalidStatusCode: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.code, into);
          return;
        }
        case ParsingError_Tags.UnknownParsingError: {
          ordinalConverter.write(5, into);
          return;
        }
        default:
          // Throwing from here means that ParsingError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ParsingError_Tags.InvalidRouteObject: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case ParsingError_Tags.InvalidGeometry: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case ParsingError_Tags.MalformedAnnotations: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case ParsingError_Tags.InvalidStatusCode: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.code);
          return size;
        }
        case ParsingError_Tags.UnknownParsingError: {
          return ordinalConverter.allocationSize(5);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RouteDeviation
export enum RouteDeviation_Tags {
  NoDeviation = 'NoDeviation',
  OffRoute = 'OffRoute',
}
/**
 * Status information that describes whether the user is proceeding according to the route or not.
 *
 * Note that the name is intentionally a bit generic to allow for expansion of other states.
 * For example, we could conceivably add a "wrong way" status in the future.
 */
export const RouteDeviation = (() => {
  type NoDeviation__interface = {
    tag: RouteDeviation_Tags.NoDeviation;
  };

  /**
   * The user is proceeding on course within the expected tolerances; everything is normal.
   */
  class NoDeviation_ extends UniffiEnum implements NoDeviation__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteDeviation';
    readonly tag = RouteDeviation_Tags.NoDeviation;
    constructor() {
      super('RouteDeviation', 'NoDeviation');
    }

    static new(): NoDeviation_ {
      return new NoDeviation_();
    }

    static instanceOf(obj: any): obj is NoDeviation_ {
      return obj.tag === RouteDeviation_Tags.NoDeviation;
    }
  }

  type OffRoute__interface = {
    tag: RouteDeviation_Tags.OffRoute;
    inner: Readonly<{ deviationFromRouteLine: /*f64*/ number }>;
  };

  /**
   * The user is off the expected route.
   */
  class OffRoute_ extends UniffiEnum implements OffRoute__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteDeviation';
    readonly tag = RouteDeviation_Tags.OffRoute;
    readonly inner: Readonly<{ deviationFromRouteLine: /*f64*/ number }>;
    constructor(inner: {
      /**
       * The deviation from the route line, in meters.
       */ deviationFromRouteLine: /*f64*/ number;
    }) {
      super('RouteDeviation', 'OffRoute');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The deviation from the route line, in meters.
       */ deviationFromRouteLine: /*f64*/ number;
    }): OffRoute_ {
      return new OffRoute_(inner);
    }

    static instanceOf(obj: any): obj is OffRoute_ {
      return obj.tag === RouteDeviation_Tags.OffRoute;
    }
  }

  function instanceOf(obj: any): obj is RouteDeviation {
    return obj[uniffiTypeNameSymbol] === 'RouteDeviation';
  }

  return Object.freeze({
    instanceOf,
    NoDeviation: NoDeviation_,
    OffRoute: OffRoute_,
  });
})();

/**
 * Status information that describes whether the user is proceeding according to the route or not.
 *
 * Note that the name is intentionally a bit generic to allow for expansion of other states.
 * For example, we could conceivably add a "wrong way" status in the future.
 */

export type RouteDeviation = InstanceType<
  (typeof RouteDeviation)[keyof Omit<typeof RouteDeviation, 'instanceOf'>]
>;

// FfiConverter for enum RouteDeviation
const FfiConverterTypeRouteDeviation = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RouteDeviation;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RouteDeviation.NoDeviation();
        case 2:
          return new RouteDeviation.OffRoute({
            deviationFromRouteLine: FfiConverterFloat64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RouteDeviation_Tags.NoDeviation: {
          ordinalConverter.write(1, into);
          return;
        }
        case RouteDeviation_Tags.OffRoute: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner.deviationFromRouteLine, into);
          return;
        }
        default:
          // Throwing from here means that RouteDeviation_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RouteDeviation_Tags.NoDeviation: {
          return ordinalConverter.allocationSize(1);
        }
        case RouteDeviation_Tags.OffRoute: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterFloat64.allocationSize(
            inner.deviationFromRouteLine
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RouteDeviationTracking
export enum RouteDeviationTracking_Tags {
  None = 'None',
  StaticThreshold = 'StaticThreshold',
  Custom = 'Custom',
}
/**
 * Determines if the user has deviated from the expected route.
 */
export const RouteDeviationTracking = (() => {
  type None__interface = {
    tag: RouteDeviationTracking_Tags.None;
  };

  /**
   * No checks will be done, and we assume the user is always following the route.
   */
  class None_ extends UniffiEnum implements None__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteDeviationTracking';
    readonly tag = RouteDeviationTracking_Tags.None;
    constructor() {
      super('RouteDeviationTracking', 'None');
    }

    static new(): None_ {
      return new None_();
    }

    static instanceOf(obj: any): obj is None_ {
      return obj.tag === RouteDeviationTracking_Tags.None;
    }
  }

  type StaticThreshold__interface = {
    tag: RouteDeviationTracking_Tags.StaticThreshold;
    inner: Readonly<{
      minimumHorizontalAccuracy: /*u16*/ number;
      maxAcceptableDeviation: /*f64*/ number;
    }>;
  };

  /**
   * Detects deviation from the route using a configurable static distance threshold from the route line.
   */
  class StaticThreshold_
    extends UniffiEnum
    implements StaticThreshold__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteDeviationTracking';
    readonly tag = RouteDeviationTracking_Tags.StaticThreshold;
    readonly inner: Readonly<{
      minimumHorizontalAccuracy: /*u16*/ number;
      maxAcceptableDeviation: /*f64*/ number;
    }>;
    constructor(inner: {
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this will not trigger route deviation warnings.
       */ minimumHorizontalAccuracy: /*u16*/ number;
      /**
       * The maximum acceptable deviation from the route line, in meters.
       *
       * If the distance between the reported location and the expected route line
       * is greater than this threshold, it will be flagged as an off route condition.
       */ maxAcceptableDeviation: /*f64*/ number;
    }) {
      super('RouteDeviationTracking', 'StaticThreshold');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this will not trigger route deviation warnings.
       */ minimumHorizontalAccuracy: /*u16*/ number;
      /**
       * The maximum acceptable deviation from the route line, in meters.
       *
       * If the distance between the reported location and the expected route line
       * is greater than this threshold, it will be flagged as an off route condition.
       */ maxAcceptableDeviation: /*f64*/ number;
    }): StaticThreshold_ {
      return new StaticThreshold_(inner);
    }

    static instanceOf(obj: any): obj is StaticThreshold_ {
      return obj.tag === RouteDeviationTracking_Tags.StaticThreshold;
    }
  }

  type Custom__interface = {
    tag: RouteDeviationTracking_Tags.Custom;
    inner: Readonly<{ detector: RouteDeviationDetector }>;
  };

  /**
   * An arbitrary user-defined implementation.
   * You decide with your own [`RouteDeviationDetector`] implementation!
   */
  class Custom_ extends UniffiEnum implements Custom__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteDeviationTracking';
    readonly tag = RouteDeviationTracking_Tags.Custom;
    readonly inner: Readonly<{ detector: RouteDeviationDetector }>;
    constructor(inner: { detector: RouteDeviationDetector }) {
      super('RouteDeviationTracking', 'Custom');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { detector: RouteDeviationDetector }): Custom_ {
      return new Custom_(inner);
    }

    static instanceOf(obj: any): obj is Custom_ {
      return obj.tag === RouteDeviationTracking_Tags.Custom;
    }
  }

  function instanceOf(obj: any): obj is RouteDeviationTracking {
    return obj[uniffiTypeNameSymbol] === 'RouteDeviationTracking';
  }

  return Object.freeze({
    instanceOf,
    None: None_,
    StaticThreshold: StaticThreshold_,
    Custom: Custom_,
  });
})();

/**
 * Determines if the user has deviated from the expected route.
 */

export type RouteDeviationTracking = InstanceType<
  (typeof RouteDeviationTracking)[keyof Omit<
    typeof RouteDeviationTracking,
    'instanceOf'
  >]
>;

// FfiConverter for enum RouteDeviationTracking
const FfiConverterTypeRouteDeviationTracking = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RouteDeviationTracking;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RouteDeviationTracking.None();
        case 2:
          return new RouteDeviationTracking.StaticThreshold({
            minimumHorizontalAccuracy: FfiConverterUInt16.read(from),
            maxAcceptableDeviation: FfiConverterFloat64.read(from),
          });
        case 3:
          return new RouteDeviationTracking.Custom({
            detector: FfiConverterTypeRouteDeviationDetector.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RouteDeviationTracking_Tags.None: {
          ordinalConverter.write(1, into);
          return;
        }
        case RouteDeviationTracking_Tags.StaticThreshold: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.minimumHorizontalAccuracy, into);
          FfiConverterFloat64.write(inner.maxAcceptableDeviation, into);
          return;
        }
        case RouteDeviationTracking_Tags.Custom: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeRouteDeviationDetector.write(inner.detector, into);
          return;
        }
        default:
          // Throwing from here means that RouteDeviationTracking_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RouteDeviationTracking_Tags.None: {
          return ordinalConverter.allocationSize(1);
        }
        case RouteDeviationTracking_Tags.StaticThreshold: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt16.allocationSize(
            inner.minimumHorizontalAccuracy
          );
          size += FfiConverterFloat64.allocationSize(
            inner.maxAcceptableDeviation
          );
          return size;
        }
        case RouteDeviationTracking_Tags.Custom: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeRouteDeviationDetector.allocationSize(
            inner.detector
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: RouteRequest
export enum RouteRequest_Tags {
  HttpPost = 'HttpPost',
  HttpGet = 'HttpGet',
}
/**
 * A route request generated by a [`RouteRequestGenerator`].
 */
export const RouteRequest = (() => {
  type HttpPost__interface = {
    tag: RouteRequest_Tags.HttpPost;
    inner: Readonly<{
      url: string;
      headers: Map<string, string>;
      body: ArrayBuffer;
    }>;
  };

  class HttpPost_ extends UniffiEnum implements HttpPost__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteRequest';
    readonly tag = RouteRequest_Tags.HttpPost;
    readonly inner: Readonly<{
      url: string;
      headers: Map<string, string>;
      body: ArrayBuffer;
    }>;
    constructor(inner: {
      url: string;
      headers: Map<string, string>;
      body: ArrayBuffer;
    }) {
      super('RouteRequest', 'HttpPost');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      url: string;
      headers: Map<string, string>;
      body: ArrayBuffer;
    }): HttpPost_ {
      return new HttpPost_(inner);
    }

    static instanceOf(obj: any): obj is HttpPost_ {
      return obj.tag === RouteRequest_Tags.HttpPost;
    }
  }

  type HttpGet__interface = {
    tag: RouteRequest_Tags.HttpGet;
    inner: Readonly<{ url: string; headers: Map<string, string> }>;
  };

  class HttpGet_ extends UniffiEnum implements HttpGet__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RouteRequest';
    readonly tag = RouteRequest_Tags.HttpGet;
    readonly inner: Readonly<{ url: string; headers: Map<string, string> }>;
    constructor(inner: { url: string; headers: Map<string, string> }) {
      super('RouteRequest', 'HttpGet');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { url: string; headers: Map<string, string> }): HttpGet_ {
      return new HttpGet_(inner);
    }

    static instanceOf(obj: any): obj is HttpGet_ {
      return obj.tag === RouteRequest_Tags.HttpGet;
    }
  }

  function instanceOf(obj: any): obj is RouteRequest {
    return obj[uniffiTypeNameSymbol] === 'RouteRequest';
  }

  return Object.freeze({
    instanceOf,
    HttpPost: HttpPost_,
    HttpGet: HttpGet_,
  });
})();

/**
 * A route request generated by a [`RouteRequestGenerator`].
 */

export type RouteRequest = InstanceType<
  (typeof RouteRequest)[keyof Omit<typeof RouteRequest, 'instanceOf'>]
>;

// FfiConverter for enum RouteRequest
const FfiConverterTypeRouteRequest = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RouteRequest;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RouteRequest.HttpPost({
            url: FfiConverterString.read(from),
            headers: FfiConverterMapStringString.read(from),
            body: FfiConverterArrayBuffer.read(from),
          });
        case 2:
          return new RouteRequest.HttpGet({
            url: FfiConverterString.read(from),
            headers: FfiConverterMapStringString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RouteRequest_Tags.HttpPost: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          FfiConverterMapStringString.write(inner.headers, into);
          FfiConverterArrayBuffer.write(inner.body, into);
          return;
        }
        case RouteRequest_Tags.HttpGet: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.url, into);
          FfiConverterMapStringString.write(inner.headers, into);
          return;
        }
        default:
          // Throwing from here means that RouteRequest_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RouteRequest_Tags.HttpPost: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.url);
          size += FfiConverterMapStringString.allocationSize(inner.headers);
          size += FfiConverterArrayBuffer.allocationSize(inner.body);
          return size;
        }
        case RouteRequest_Tags.HttpGet: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.url);
          size += FfiConverterMapStringString.allocationSize(inner.headers);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: RoutingRequestGenerationError

// Enum: RoutingRequestGenerationError
export enum RoutingRequestGenerationError_Tags {
  NotEnoughWaypoints = 'NotEnoughWaypoints',
  JsonError = 'JsonError',
  UnknownRequestGenerationError = 'UnknownRequestGenerationError',
}
export const RoutingRequestGenerationError = (() => {
  type NotEnoughWaypoints__interface = {
    tag: RoutingRequestGenerationError_Tags.NotEnoughWaypoints;
  };

  class NotEnoughWaypoints_
    extends UniffiError
    implements NotEnoughWaypoints__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoutingRequestGenerationError';
    readonly tag = RoutingRequestGenerationError_Tags.NotEnoughWaypoints;
    constructor() {
      super('RoutingRequestGenerationError', 'NotEnoughWaypoints');
    }

    static new(): NotEnoughWaypoints_ {
      return new NotEnoughWaypoints_();
    }

    static instanceOf(obj: any): obj is NotEnoughWaypoints_ {
      return obj.tag === RoutingRequestGenerationError_Tags.NotEnoughWaypoints;
    }

    static hasInner(obj: any): obj is NotEnoughWaypoints_ {
      return false;
    }
  }

  type JsonError__interface = {
    tag: RoutingRequestGenerationError_Tags.JsonError;
  };

  class JsonError_ extends UniffiError implements JsonError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoutingRequestGenerationError';
    readonly tag = RoutingRequestGenerationError_Tags.JsonError;
    constructor() {
      super('RoutingRequestGenerationError', 'JsonError');
    }

    static new(): JsonError_ {
      return new JsonError_();
    }

    static instanceOf(obj: any): obj is JsonError_ {
      return obj.tag === RoutingRequestGenerationError_Tags.JsonError;
    }

    static hasInner(obj: any): obj is JsonError_ {
      return false;
    }
  }

  type UnknownRequestGenerationError__interface = {
    tag: RoutingRequestGenerationError_Tags.UnknownRequestGenerationError;
  };

  class UnknownRequestGenerationError_
    extends UniffiError
    implements UnknownRequestGenerationError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'RoutingRequestGenerationError';
    readonly tag =
      RoutingRequestGenerationError_Tags.UnknownRequestGenerationError;
    constructor() {
      super('RoutingRequestGenerationError', 'UnknownRequestGenerationError');
    }

    static new(): UnknownRequestGenerationError_ {
      return new UnknownRequestGenerationError_();
    }

    static instanceOf(obj: any): obj is UnknownRequestGenerationError_ {
      return (
        obj.tag ===
        RoutingRequestGenerationError_Tags.UnknownRequestGenerationError
      );
    }

    static hasInner(obj: any): obj is UnknownRequestGenerationError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is RoutingRequestGenerationError {
    return obj[uniffiTypeNameSymbol] === 'RoutingRequestGenerationError';
  }

  return Object.freeze({
    instanceOf,
    NotEnoughWaypoints: NotEnoughWaypoints_,
    JsonError: JsonError_,
    UnknownRequestGenerationError: UnknownRequestGenerationError_,
  });
})();

export type RoutingRequestGenerationError = InstanceType<
  (typeof RoutingRequestGenerationError)[keyof Omit<
    typeof RoutingRequestGenerationError,
    'instanceOf'
  >]
>;

// FfiConverter for enum RoutingRequestGenerationError
const FfiConverterTypeRoutingRequestGenerationError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = RoutingRequestGenerationError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new RoutingRequestGenerationError.NotEnoughWaypoints();
        case 2:
          return new RoutingRequestGenerationError.JsonError();
        case 3:
          return new RoutingRequestGenerationError.UnknownRequestGenerationError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case RoutingRequestGenerationError_Tags.NotEnoughWaypoints: {
          ordinalConverter.write(1, into);
          return;
        }
        case RoutingRequestGenerationError_Tags.JsonError: {
          ordinalConverter.write(2, into);
          return;
        }
        case RoutingRequestGenerationError_Tags.UnknownRequestGenerationError: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that RoutingRequestGenerationError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case RoutingRequestGenerationError_Tags.NotEnoughWaypoints: {
          return ordinalConverter.allocationSize(1);
        }
        case RoutingRequestGenerationError_Tags.JsonError: {
          return ordinalConverter.allocationSize(2);
        }
        case RoutingRequestGenerationError_Tags.UnknownRequestGenerationError: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SimulationError

// Enum: SimulationError
export enum SimulationError_Tags {
  PolylineError = 'PolylineError',
  NotEnoughPoints = 'NotEnoughPoints',
}
export const SimulationError = (() => {
  type PolylineError__interface = {
    tag: SimulationError_Tags.PolylineError;
    inner: Readonly<{ error: string }>;
  };

  /**
   * Errors decoding the polyline string.
   */
  class PolylineError_ extends UniffiError implements PolylineError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SimulationError';
    readonly tag = SimulationError_Tags.PolylineError;
    readonly inner: Readonly<{ error: string }>;
    constructor(inner: { error: string }) {
      super('SimulationError', 'PolylineError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { error: string }): PolylineError_ {
      return new PolylineError_(inner);
    }

    static instanceOf(obj: any): obj is PolylineError_ {
      return obj.tag === SimulationError_Tags.PolylineError;
    }

    static hasInner(obj: any): obj is PolylineError_ {
      return PolylineError_.instanceOf(obj);
    }

    static getInner(obj: PolylineError_): Readonly<{ error: string }> {
      return obj.inner;
    }
  }

  type NotEnoughPoints__interface = {
    tag: SimulationError_Tags.NotEnoughPoints;
  };

  /**
   * Not enough points in the input.
   */
  class NotEnoughPoints_
    extends UniffiError
    implements NotEnoughPoints__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SimulationError';
    readonly tag = SimulationError_Tags.NotEnoughPoints;
    constructor() {
      super('SimulationError', 'NotEnoughPoints');
    }

    static new(): NotEnoughPoints_ {
      return new NotEnoughPoints_();
    }

    static instanceOf(obj: any): obj is NotEnoughPoints_ {
      return obj.tag === SimulationError_Tags.NotEnoughPoints;
    }

    static hasInner(obj: any): obj is NotEnoughPoints_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is SimulationError {
    return obj[uniffiTypeNameSymbol] === 'SimulationError';
  }

  return Object.freeze({
    instanceOf,
    PolylineError: PolylineError_,
    NotEnoughPoints: NotEnoughPoints_,
  });
})();

export type SimulationError = InstanceType<
  (typeof SimulationError)[keyof Omit<typeof SimulationError, 'instanceOf'>]
>;

// FfiConverter for enum SimulationError
const FfiConverterTypeSimulationError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SimulationError;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SimulationError.PolylineError({
            error: FfiConverterString.read(from),
          });
        case 2:
          return new SimulationError.NotEnoughPoints();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SimulationError_Tags.PolylineError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.error, into);
          return;
        }
        case SimulationError_Tags.NotEnoughPoints: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that SimulationError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SimulationError_Tags.PolylineError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.error);
          return size;
        }
        case SimulationError_Tags.NotEnoughPoints: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: SpecialAdvanceConditions
export enum SpecialAdvanceConditions_Tags {
  AdvanceAtDistanceFromEnd = 'AdvanceAtDistanceFromEnd',
  MinimumDistanceFromCurrentStepLine = 'MinimumDistanceFromCurrentStepLine',
}
/**
 * Special conditions which alter the normal step advance logic,
 */
export const SpecialAdvanceConditions = (() => {
  type AdvanceAtDistanceFromEnd__interface = {
    tag: SpecialAdvanceConditions_Tags.AdvanceAtDistanceFromEnd;
    inner: Readonly<[/*u16*/ number]>;
  };

  /**
   * Allows navigation to advance to the next step as soon as the user
   * comes within this distance (in meters) of the end of the current step.
   *
   * This results in *early* advance when the user is near the goal.
   */
  class AdvanceAtDistanceFromEnd_
    extends UniffiEnum
    implements AdvanceAtDistanceFromEnd__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SpecialAdvanceConditions';
    readonly tag = SpecialAdvanceConditions_Tags.AdvanceAtDistanceFromEnd;
    readonly inner: Readonly<[/*u16*/ number]>;
    constructor(v0: /*u16*/ number) {
      super('SpecialAdvanceConditions', 'AdvanceAtDistanceFromEnd');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*u16*/ number): AdvanceAtDistanceFromEnd_ {
      return new AdvanceAtDistanceFromEnd_(v0);
    }

    static instanceOf(obj: any): obj is AdvanceAtDistanceFromEnd_ {
      return obj.tag === SpecialAdvanceConditions_Tags.AdvanceAtDistanceFromEnd;
    }
  }

  type MinimumDistanceFromCurrentStepLine__interface = {
    tag: SpecialAdvanceConditions_Tags.MinimumDistanceFromCurrentStepLine;
    inner: Readonly<[/*u16*/ number]>;
  };

  /**
   * Requires that the user be at least this far (distance in meters)
   * from the current route step.
   *
   * This results in *delayed* advance,
   * but is more robust to spurious / unwanted step changes in scenarios including
   * self-intersecting routes (sudden jump to the next step)
   * and pauses at intersections (advancing too soon before the maneuver is complete).
   *
   * Note that this could be theoretically less robust to things like U-turns,
   * but we need a bit more real-world testing to confirm if it's an issue.
   */
  class MinimumDistanceFromCurrentStepLine_
    extends UniffiEnum
    implements MinimumDistanceFromCurrentStepLine__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SpecialAdvanceConditions';
    readonly tag =
      SpecialAdvanceConditions_Tags.MinimumDistanceFromCurrentStepLine;
    readonly inner: Readonly<[/*u16*/ number]>;
    constructor(v0: /*u16*/ number) {
      super('SpecialAdvanceConditions', 'MinimumDistanceFromCurrentStepLine');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: /*u16*/ number): MinimumDistanceFromCurrentStepLine_ {
      return new MinimumDistanceFromCurrentStepLine_(v0);
    }

    static instanceOf(obj: any): obj is MinimumDistanceFromCurrentStepLine_ {
      return (
        obj.tag ===
        SpecialAdvanceConditions_Tags.MinimumDistanceFromCurrentStepLine
      );
    }
  }

  function instanceOf(obj: any): obj is SpecialAdvanceConditions {
    return obj[uniffiTypeNameSymbol] === 'SpecialAdvanceConditions';
  }

  return Object.freeze({
    instanceOf,
    AdvanceAtDistanceFromEnd: AdvanceAtDistanceFromEnd_,
    MinimumDistanceFromCurrentStepLine: MinimumDistanceFromCurrentStepLine_,
  });
})();

/**
 * Special conditions which alter the normal step advance logic,
 */

export type SpecialAdvanceConditions = InstanceType<
  (typeof SpecialAdvanceConditions)[keyof Omit<
    typeof SpecialAdvanceConditions,
    'instanceOf'
  >]
>;

// FfiConverter for enum SpecialAdvanceConditions
const FfiConverterTypeSpecialAdvanceConditions = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SpecialAdvanceConditions;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SpecialAdvanceConditions.AdvanceAtDistanceFromEnd(
            FfiConverterUInt16.read(from)
          );
        case 2:
          return new SpecialAdvanceConditions.MinimumDistanceFromCurrentStepLine(
            FfiConverterUInt16.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SpecialAdvanceConditions_Tags.AdvanceAtDistanceFromEnd: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner[0], into);
          return;
        }
        case SpecialAdvanceConditions_Tags.MinimumDistanceFromCurrentStepLine: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SpecialAdvanceConditions_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SpecialAdvanceConditions_Tags.AdvanceAtDistanceFromEnd: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt16.allocationSize(inner[0]);
          return size;
        }
        case SpecialAdvanceConditions_Tags.MinimumDistanceFromCurrentStepLine: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt16.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: StepAdvanceMode
export enum StepAdvanceMode_Tags {
  Manual = 'Manual',
  DistanceToEndOfStep = 'DistanceToEndOfStep',
  RelativeLineStringDistance = 'RelativeLineStringDistance',
}
/**
 * The step advance mode describes when the current maneuver has been successfully completed,
 * and we should advance to the next step.
 */
export const StepAdvanceMode = (() => {
  type Manual__interface = {
    tag: StepAdvanceMode_Tags.Manual;
  };

  /**
   * Never advances to the next step automatically;
   * requires calling [`NavigationController::advance_to_next_step`](super::NavigationController::advance_to_next_step).
   *
   * You can use this to implement custom behaviors in external code.
   */
  class Manual_ extends UniffiEnum implements Manual__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StepAdvanceMode';
    readonly tag = StepAdvanceMode_Tags.Manual;
    constructor() {
      super('StepAdvanceMode', 'Manual');
    }

    static new(): Manual_ {
      return new Manual_();
    }

    static instanceOf(obj: any): obj is Manual_ {
      return obj.tag === StepAdvanceMode_Tags.Manual;
    }
  }

  type DistanceToEndOfStep__interface = {
    tag: StepAdvanceMode_Tags.DistanceToEndOfStep;
    inner: Readonly<{
      distance: /*u16*/ number;
      minimumHorizontalAccuracy: /*u16*/ number;
    }>;
  };

  /**
   * Automatically advances when the user's location is close enough to the end of the step
   */
  class DistanceToEndOfStep_
    extends UniffiEnum
    implements DistanceToEndOfStep__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StepAdvanceMode';
    readonly tag = StepAdvanceMode_Tags.DistanceToEndOfStep;
    readonly inner: Readonly<{
      distance: /*u16*/ number;
      minimumHorizontalAccuracy: /*u16*/ number;
    }>;
    constructor(inner: {
      /**
       * Distance to the last waypoint in the step, measured in meters, at which to advance.
       */ distance: /*u16*/ number;
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this cannot trigger a step advance.
       */ minimumHorizontalAccuracy: /*u16*/ number;
    }) {
      super('StepAdvanceMode', 'DistanceToEndOfStep');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * Distance to the last waypoint in the step, measured in meters, at which to advance.
       */ distance: /*u16*/ number;
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this cannot trigger a step advance.
       */ minimumHorizontalAccuracy: /*u16*/ number;
    }): DistanceToEndOfStep_ {
      return new DistanceToEndOfStep_(inner);
    }

    static instanceOf(obj: any): obj is DistanceToEndOfStep_ {
      return obj.tag === StepAdvanceMode_Tags.DistanceToEndOfStep;
    }
  }

  type RelativeLineStringDistance__interface = {
    tag: StepAdvanceMode_Tags.RelativeLineStringDistance;
    inner: Readonly<{
      minimumHorizontalAccuracy: /*u16*/ number;
      specialAdvanceConditions: SpecialAdvanceConditions | undefined;
    }>;
  };

  /**
   * Automatically advances when the user's distance to the *next* step's linestring  is less
   * than the distance to the current step's linestring, subject to certain conditions.
   */
  class RelativeLineStringDistance_
    extends UniffiEnum
    implements RelativeLineStringDistance__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'StepAdvanceMode';
    readonly tag = StepAdvanceMode_Tags.RelativeLineStringDistance;
    readonly inner: Readonly<{
      minimumHorizontalAccuracy: /*u16*/ number;
      specialAdvanceConditions: SpecialAdvanceConditions | undefined;
    }>;
    constructor(inner: {
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this cannot ever trigger a step advance.
       */ minimumHorizontalAccuracy: /*u16*/ number;
      /**
       * Optional extra conditions which refine the step advance logic.
       *
       * See the enum variant documentation for details.
       */ specialAdvanceConditions: SpecialAdvanceConditions | undefined;
    }) {
      super('StepAdvanceMode', 'RelativeLineStringDistance');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The minimum required horizontal accuracy of the user location, in meters.
       * Values larger than this cannot ever trigger a step advance.
       */ minimumHorizontalAccuracy: /*u16*/ number;
      /**
       * Optional extra conditions which refine the step advance logic.
       *
       * See the enum variant documentation for details.
       */ specialAdvanceConditions: SpecialAdvanceConditions | undefined;
    }): RelativeLineStringDistance_ {
      return new RelativeLineStringDistance_(inner);
    }

    static instanceOf(obj: any): obj is RelativeLineStringDistance_ {
      return obj.tag === StepAdvanceMode_Tags.RelativeLineStringDistance;
    }
  }

  function instanceOf(obj: any): obj is StepAdvanceMode {
    return obj[uniffiTypeNameSymbol] === 'StepAdvanceMode';
  }

  return Object.freeze({
    instanceOf,
    Manual: Manual_,
    DistanceToEndOfStep: DistanceToEndOfStep_,
    RelativeLineStringDistance: RelativeLineStringDistance_,
  });
})();

/**
 * The step advance mode describes when the current maneuver has been successfully completed,
 * and we should advance to the next step.
 */

export type StepAdvanceMode = InstanceType<
  (typeof StepAdvanceMode)[keyof Omit<typeof StepAdvanceMode, 'instanceOf'>]
>;

// FfiConverter for enum StepAdvanceMode
const FfiConverterTypeStepAdvanceMode = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = StepAdvanceMode;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new StepAdvanceMode.Manual();
        case 2:
          return new StepAdvanceMode.DistanceToEndOfStep({
            distance: FfiConverterUInt16.read(from),
            minimumHorizontalAccuracy: FfiConverterUInt16.read(from),
          });
        case 3:
          return new StepAdvanceMode.RelativeLineStringDistance({
            minimumHorizontalAccuracy: FfiConverterUInt16.read(from),
            specialAdvanceConditions:
              FfiConverterOptionalTypeSpecialAdvanceConditions.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case StepAdvanceMode_Tags.Manual: {
          ordinalConverter.write(1, into);
          return;
        }
        case StepAdvanceMode_Tags.DistanceToEndOfStep: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.distance, into);
          FfiConverterUInt16.write(inner.minimumHorizontalAccuracy, into);
          return;
        }
        case StepAdvanceMode_Tags.RelativeLineStringDistance: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt16.write(inner.minimumHorizontalAccuracy, into);
          FfiConverterOptionalTypeSpecialAdvanceConditions.write(
            inner.specialAdvanceConditions,
            into
          );
          return;
        }
        default:
          // Throwing from here means that StepAdvanceMode_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case StepAdvanceMode_Tags.Manual: {
          return ordinalConverter.allocationSize(1);
        }
        case StepAdvanceMode_Tags.DistanceToEndOfStep: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt16.allocationSize(inner.distance);
          size += FfiConverterUInt16.allocationSize(
            inner.minimumHorizontalAccuracy
          );
          return size;
        }
        case StepAdvanceMode_Tags.RelativeLineStringDistance: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt16.allocationSize(
            inner.minimumHorizontalAccuracy
          );
          size +=
            FfiConverterOptionalTypeSpecialAdvanceConditions.allocationSize(
              inner.specialAdvanceConditions
            );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TripState
export enum TripState_Tags {
  Idle = 'Idle',
  Navigating = 'Navigating',
  Complete = 'Complete',
}
/**
 * The state of a navigation session.
 *
 * This is produced by [`NavigationController`](super::NavigationController) methods
 * including [`get_initial_state`](super::NavigationController::get_initial_state)
 * and [`update_user_location`](super::NavigationController::update_user_location).
 */
export const TripState = (() => {
  type Idle__interface = {
    tag: TripState_Tags.Idle;
  };

  /**
   * The navigation controller is idle and there is no active trip.
   */
  class Idle_ extends UniffiEnum implements Idle__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TripState';
    readonly tag = TripState_Tags.Idle;
    constructor() {
      super('TripState', 'Idle');
    }

    static new(): Idle_ {
      return new Idle_();
    }

    static instanceOf(obj: any): obj is Idle_ {
      return obj.tag === TripState_Tags.Idle;
    }
  }

  type Navigating__interface = {
    tag: TripState_Tags.Navigating;
    inner: Readonly<{
      currentStepGeometryIndex: /*u64*/ bigint | undefined;
      snappedUserLocation: UserLocation;
      remainingSteps: Array<RouteStep>;
      remainingWaypoints: Array<Waypoint>;
      progress: TripProgress;
      deviation: RouteDeviation;
      visualInstruction: VisualInstruction | undefined;
      spokenInstruction: SpokenInstruction | undefined;
      annotationJson: string | undefined;
    }>;
  };

  /**
   * The navigation controller is actively navigating a trip.
   */
  class Navigating_ extends UniffiEnum implements Navigating__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TripState';
    readonly tag = TripState_Tags.Navigating;
    readonly inner: Readonly<{
      currentStepGeometryIndex: /*u64*/ bigint | undefined;
      snappedUserLocation: UserLocation;
      remainingSteps: Array<RouteStep>;
      remainingWaypoints: Array<Waypoint>;
      progress: TripProgress;
      deviation: RouteDeviation;
      visualInstruction: VisualInstruction | undefined;
      spokenInstruction: SpokenInstruction | undefined;
      annotationJson: string | undefined;
    }>;
    constructor(inner: {
      /**
       * The index of the closest coordinate to the user's snapped location.
       *
       * This index is relative to the *current* [`RouteStep`]'s geometry.
       */ currentStepGeometryIndex: /*u64*/ bigint | undefined;
      /**
       * A location on the line string that
       */ snappedUserLocation: UserLocation;
      /**
       * The ordered list of steps that remain in the trip.
       *
       * The step at the front of the list is always the current step.
       * We currently assume that you cannot move backward to a previous step.
       */ remainingSteps: Array<RouteStep>;
      /**
       * Remaining waypoints to visit on the route.
       *
       * The waypoint at the front of the list is always the *next* waypoint "goal."
       * Unlike the current step, there is no value in tracking the "current" waypoint,
       * as the main use of waypoints is recalculation when the user deviates from the route.
       * (In most use cases, a route will have only two waypoints, but more complex use cases
       * may have multiple intervening points that are visited along the route.)
       * This list is updated as the user advances through the route.
       */ remainingWaypoints: Array<Waypoint>;
      /**
       * The trip progress includes information that is useful for showing the
       * user's progress along the full navigation trip, the route and its components.
       */ progress: TripProgress;
      /**
       * The route deviation status: is the user following the route or not?
       */ deviation: RouteDeviation;
      /**
       * The visual instruction that should be displayed in the user interface.
       */ visualInstruction: VisualInstruction | undefined;
      /**
       * The most recent spoken instruction that should be synthesized using TTS.
       *
       * Note it is the responsibility of the platform layer to ensure that utterances are not synthesized multiple times. This property simply reports the current spoken instruction.
       */ spokenInstruction: SpokenInstruction | undefined;
      /**
       * Annotation data at the current location.
       * This is represented as a json formatted byte array to allow for flexible encoding of custom annotations.
       */ annotationJson: string | undefined;
    }) {
      super('TripState', 'Navigating');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      /**
       * The index of the closest coordinate to the user's snapped location.
       *
       * This index is relative to the *current* [`RouteStep`]'s geometry.
       */ currentStepGeometryIndex: /*u64*/ bigint | undefined;
      /**
       * A location on the line string that
       */ snappedUserLocation: UserLocation;
      /**
       * The ordered list of steps that remain in the trip.
       *
       * The step at the front of the list is always the current step.
       * We currently assume that you cannot move backward to a previous step.
       */ remainingSteps: Array<RouteStep>;
      /**
       * Remaining waypoints to visit on the route.
       *
       * The waypoint at the front of the list is always the *next* waypoint "goal."
       * Unlike the current step, there is no value in tracking the "current" waypoint,
       * as the main use of waypoints is recalculation when the user deviates from the route.
       * (In most use cases, a route will have only two waypoints, but more complex use cases
       * may have multiple intervening points that are visited along the route.)
       * This list is updated as the user advances through the route.
       */ remainingWaypoints: Array<Waypoint>;
      /**
       * The trip progress includes information that is useful for showing the
       * user's progress along the full navigation trip, the route and its components.
       */ progress: TripProgress;
      /**
       * The route deviation status: is the user following the route or not?
       */ deviation: RouteDeviation;
      /**
       * The visual instruction that should be displayed in the user interface.
       */ visualInstruction: VisualInstruction | undefined;
      /**
       * The most recent spoken instruction that should be synthesized using TTS.
       *
       * Note it is the responsibility of the platform layer to ensure that utterances are not synthesized multiple times. This property simply reports the current spoken instruction.
       */ spokenInstruction: SpokenInstruction | undefined;
      /**
       * Annotation data at the current location.
       * This is represented as a json formatted byte array to allow for flexible encoding of custom annotations.
       */ annotationJson: string | undefined;
    }): Navigating_ {
      return new Navigating_(inner);
    }

    static instanceOf(obj: any): obj is Navigating_ {
      return obj.tag === TripState_Tags.Navigating;
    }
  }

  type Complete__interface = {
    tag: TripState_Tags.Complete;
  };

  /**
   * The navigation controller has reached the end of the trip.
   */
  class Complete_ extends UniffiEnum implements Complete__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TripState';
    readonly tag = TripState_Tags.Complete;
    constructor() {
      super('TripState', 'Complete');
    }

    static new(): Complete_ {
      return new Complete_();
    }

    static instanceOf(obj: any): obj is Complete_ {
      return obj.tag === TripState_Tags.Complete;
    }
  }

  function instanceOf(obj: any): obj is TripState {
    return obj[uniffiTypeNameSymbol] === 'TripState';
  }

  return Object.freeze({
    instanceOf,
    Idle: Idle_,
    Navigating: Navigating_,
    Complete: Complete_,
  });
})();

/**
 * The state of a navigation session.
 *
 * This is produced by [`NavigationController`](super::NavigationController) methods
 * including [`get_initial_state`](super::NavigationController::get_initial_state)
 * and [`update_user_location`](super::NavigationController::update_user_location).
 */

export type TripState = InstanceType<
  (typeof TripState)[keyof Omit<typeof TripState, 'instanceOf'>]
>;

// FfiConverter for enum TripState
const FfiConverterTypeTripState = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TripState;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TripState.Idle();
        case 2:
          return new TripState.Navigating({
            currentStepGeometryIndex: FfiConverterOptionalUInt64.read(from),
            snappedUserLocation: FfiConverterTypeUserLocation.read(from),
            remainingSteps: FfiConverterArrayTypeRouteStep.read(from),
            remainingWaypoints: FfiConverterArrayTypeWaypoint.read(from),
            progress: FfiConverterTypeTripProgress.read(from),
            deviation: FfiConverterTypeRouteDeviation.read(from),
            visualInstruction:
              FfiConverterOptionalTypeVisualInstruction.read(from),
            spokenInstruction:
              FfiConverterOptionalTypeSpokenInstruction.read(from),
            annotationJson: FfiConverterOptionalString.read(from),
          });
        case 3:
          return new TripState.Complete();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TripState_Tags.Idle: {
          ordinalConverter.write(1, into);
          return;
        }
        case TripState_Tags.Navigating: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterOptionalUInt64.write(
            inner.currentStepGeometryIndex,
            into
          );
          FfiConverterTypeUserLocation.write(inner.snappedUserLocation, into);
          FfiConverterArrayTypeRouteStep.write(inner.remainingSteps, into);
          FfiConverterArrayTypeWaypoint.write(inner.remainingWaypoints, into);
          FfiConverterTypeTripProgress.write(inner.progress, into);
          FfiConverterTypeRouteDeviation.write(inner.deviation, into);
          FfiConverterOptionalTypeVisualInstruction.write(
            inner.visualInstruction,
            into
          );
          FfiConverterOptionalTypeSpokenInstruction.write(
            inner.spokenInstruction,
            into
          );
          FfiConverterOptionalString.write(inner.annotationJson, into);
          return;
        }
        case TripState_Tags.Complete: {
          ordinalConverter.write(3, into);
          return;
        }
        default:
          // Throwing from here means that TripState_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TripState_Tags.Idle: {
          return ordinalConverter.allocationSize(1);
        }
        case TripState_Tags.Navigating: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterOptionalUInt64.allocationSize(
            inner.currentStepGeometryIndex
          );
          size += FfiConverterTypeUserLocation.allocationSize(
            inner.snappedUserLocation
          );
          size += FfiConverterArrayTypeRouteStep.allocationSize(
            inner.remainingSteps
          );
          size += FfiConverterArrayTypeWaypoint.allocationSize(
            inner.remainingWaypoints
          );
          size += FfiConverterTypeTripProgress.allocationSize(inner.progress);
          size += FfiConverterTypeRouteDeviation.allocationSize(
            inner.deviation
          );
          size += FfiConverterOptionalTypeVisualInstruction.allocationSize(
            inner.visualInstruction
          );
          size += FfiConverterOptionalTypeSpokenInstruction.allocationSize(
            inner.spokenInstruction
          );
          size += FfiConverterOptionalString.allocationSize(
            inner.annotationJson
          );
          return size;
        }
        case TripState_Tags.Complete: {
          return ordinalConverter.allocationSize(3);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * Describes characteristics of the waypoint for the routing backend.
 */
export enum WaypointKind {
  /**
   * Starts or ends a leg of the trip.
   *
   * Most routing engines will generate arrival and departure instructions.
   */
  Break,
  /**
   * A waypoint that is simply passed through, but will not have any arrival or departure instructions.
   */
  Via,
}

const FfiConverterTypeWaypointKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = WaypointKind;
  class FFIConverter extends AbstractFfiConverterArrayBuffer<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return WaypointKind.Break;
        case 2:
          return WaypointKind.Via;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case WaypointKind.Break:
          return ordinalConverter.write(1, into);
        case WaypointKind.Via:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

/**
 * Manages the navigation lifecycle through a route,
 * returning an updated state given inputs like user location.
 *
 * Notes for implementing a new platform:
 * - A controller is bound to a single route; if you want recalculation, create a new instance.
 * - This is a pure type (no interior mutability), so a core function of your platform code is responsibly managing mutable state.
 */
export interface NavigationControllerInterface {
  /**
   * Advances navigation to the next step.
   *
   * Depending on the advancement strategy, this may be automatic.
   * For other cases, it is desirable to advance to the next step manually (ex: walking in an
   * urban tunnel). We leave this decision to the app developer and provide this as a convenience.
   *
   * This method is takes the intermediate state (e.g. from `update_user_location`) and advances if necessary.
   * As a result, you do not to re-calculate things like deviation or the snapped user location (search this file for usage of this function).
   */
  advanceToNextStep(state: TripState): TripState;
  /**
   * Returns initial trip state as if the user had just started the route with no progress.
   */
  getInitialState(location: UserLocation): TripState;
  /**
   * Updates the user's current location and updates the navigation state accordingly.
   *
   * # Panics
   *
   * If there is no current step ([`TripState::Navigating`] has an empty `remainingSteps` value),
   * this function will panic.
   */
  updateUserLocation(location: UserLocation, state: TripState): TripState;
}

/**
 * Manages the navigation lifecycle through a route,
 * returning an updated state given inputs like user location.
 *
 * Notes for implementing a new platform:
 * - A controller is bound to a single route; if you want recalculation, create a new instance.
 * - This is a pure type (no interior mutability), so a core function of your platform code is responsibly managing mutable state.
 */
export class NavigationController
  extends UniffiAbstractObject
  implements NavigationControllerInterface
{
  readonly [uniffiTypeNameSymbol] = 'NavigationController';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a navigation controller for a route and configuration.
   */
  constructor(route: Route, config: NavigationControllerConfig) {
    super();
    const pointer = rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_constructor_navigationcontroller_new(
          FfiConverterTypeRoute.lower(route),
          FfiConverterTypeNavigationControllerConfig.lower(config),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeNavigationControllerObjectFactory.bless(pointer);
  }

  /**
   * Advances navigation to the next step.
   *
   * Depending on the advancement strategy, this may be automatic.
   * For other cases, it is desirable to advance to the next step manually (ex: walking in an
   * urban tunnel). We leave this decision to the app developer and provide this as a convenience.
   *
   * This method is takes the intermediate state (e.g. from `update_user_location`) and advances if necessary.
   * As a result, you do not to re-calculate things like deviation or the snapped user location (search this file for usage of this function).
   */
  public advanceToNextStep(state: TripState): TripState {
    return FfiConverterTypeTripState.lift(
      rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_navigationcontroller_advance_to_next_step(
            uniffiTypeNavigationControllerObjectFactory.clonePointer(this),
            FfiConverterTypeTripState.lower(state),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Returns initial trip state as if the user had just started the route with no progress.
   */
  public getInitialState(location: UserLocation): TripState {
    return FfiConverterTypeTripState.lift(
      rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_navigationcontroller_get_initial_state(
            uniffiTypeNavigationControllerObjectFactory.clonePointer(this),
            FfiConverterTypeUserLocation.lower(location),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Updates the user's current location and updates the navigation state accordingly.
   *
   * # Panics
   *
   * If there is no current step ([`TripState::Navigating`] has an empty `remainingSteps` value),
   * this function will panic.
   */
  public updateUserLocation(
    location: UserLocation,
    state: TripState
  ): TripState {
    return FfiConverterTypeTripState.lift(
      rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_navigationcontroller_update_user_location(
            uniffiTypeNavigationControllerObjectFactory.clonePointer(this),
            FfiConverterTypeUserLocation.lower(location),
            FfiConverterTypeTripState.lower(state),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer = uniffiTypeNavigationControllerObjectFactory.pointer(this);
      uniffiTypeNavigationControllerObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is NavigationController {
    return uniffiTypeNavigationControllerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeNavigationControllerObjectFactory: UniffiObjectFactory<NavigationControllerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): NavigationControllerInterface {
      const instance = Object.create(NavigationController.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'NavigationController';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_navigationcontroller_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: NavigationControllerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: NavigationControllerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_clone_navigationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_free_navigationcontroller(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is NavigationControllerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'NavigationController'
      );
    },
  };
// FfiConverter for NavigationControllerInterface
const FfiConverterTypeNavigationController = new FfiConverterObject(
  uniffiTypeNavigationControllerObjectFactory
);

/**
 * The route adapter bridges between the common core and a routing backend where interaction takes place
 * over a generic request/response flow (typically over a network;
 * local/offline routers **do not use this object** as the interaction patterns are different).
 *
 * This is essentially the composite of the [`RouteRequestGenerator`] and [`RouteResponseParser`]
 * traits, but it provides one further level of abstraction which is helpful to consumers.
 * As there is no way to signal compatibility between request generators and response parsers,
 * the [`RouteAdapter`] provides convenience constructors which take the guesswork out of it,
 * while still leaving consumers free to implement one or both halves.
 *
 * In the future, we may provide additional methods or conveniences, and this
 * indirection leaves the design open to such changes without necessarily breaking source
 * compatibility.
 * One such possible extension would be the ability to fetch more detailed attributes in real time.
 * This is supported by the Valhalla stack, among others.
 *
 * Ideas  welcome re: how to signal compatibility between request generators and response parsers.
 * I don't think we can do this in the type system, since one of the reasons for the split design
 * is modularity, including the possibility of user-provided implementations, and these will not
 * always be of a "known" type to the Rust side.
 */
export interface RouteAdapterInterface {
  generateRequest(
    userLocation: UserLocation,
    waypoints: Array<Waypoint>
  ) /*throws*/ : RouteRequest;
  parseResponse(response: ArrayBuffer) /*throws*/ : Array<Route>;
}

/**
 * The route adapter bridges between the common core and a routing backend where interaction takes place
 * over a generic request/response flow (typically over a network;
 * local/offline routers **do not use this object** as the interaction patterns are different).
 *
 * This is essentially the composite of the [`RouteRequestGenerator`] and [`RouteResponseParser`]
 * traits, but it provides one further level of abstraction which is helpful to consumers.
 * As there is no way to signal compatibility between request generators and response parsers,
 * the [`RouteAdapter`] provides convenience constructors which take the guesswork out of it,
 * while still leaving consumers free to implement one or both halves.
 *
 * In the future, we may provide additional methods or conveniences, and this
 * indirection leaves the design open to such changes without necessarily breaking source
 * compatibility.
 * One such possible extension would be the ability to fetch more detailed attributes in real time.
 * This is supported by the Valhalla stack, among others.
 *
 * Ideas  welcome re: how to signal compatibility between request generators and response parsers.
 * I don't think we can do this in the type system, since one of the reasons for the split design
 * is modularity, including the possibility of user-provided implementations, and these will not
 * always be of a "known" type to the Rust side.
 */
export class RouteAdapter
  extends UniffiAbstractObject
  implements RouteAdapterInterface
{
  readonly [uniffiTypeNameSymbol] = 'RouteAdapter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    requestGenerator: RouteRequestGenerator,
    responseParser: RouteResponseParser
  ) {
    super();
    const pointer = rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().uniffi_ferrostar_fn_constructor_routeadapter_new(
          FfiConverterTypeRouteRequestGenerator.lower(requestGenerator),
          FfiConverterTypeRouteResponseParser.lower(responseParser),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRouteAdapterObjectFactory.bless(pointer);
  }

  public static newValhallaHttp(
    endpointUrl: string,
    profile: string,
    optionsJson: string | undefined
  ): RouteAdapterInterface /*throws*/ {
    return FfiConverterTypeRouteAdapter.lift(
      rustCallWithError(
        /*liftError:*/ FfiConverterTypeInstantiationError.lift.bind(
          FfiConverterTypeInstantiationError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_constructor_routeadapter_new_valhalla_http(
            FfiConverterString.lower(endpointUrl),
            FfiConverterString.lower(profile),
            FfiConverterOptionalString.lower(optionsJson),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public generateRequest(
    userLocation: UserLocation,
    waypoints: Array<Waypoint>
  ): RouteRequest /*throws*/ {
    return FfiConverterTypeRouteRequest.lift(
      rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoutingRequestGenerationError.lift.bind(
          FfiConverterTypeRoutingRequestGenerationError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_routeadapter_generate_request(
            uniffiTypeRouteAdapterObjectFactory.clonePointer(this),
            FfiConverterTypeUserLocation.lower(userLocation),
            FfiConverterArrayTypeWaypoint.lower(waypoints),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public parseResponse(response: ArrayBuffer): Array<Route> /*throws*/ {
    return FfiConverterArrayTypeRoute.lift(
      rustCallWithError(
        /*liftError:*/ FfiConverterTypeParsingError.lift.bind(
          FfiConverterTypeParsingError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_routeadapter_parse_response(
            uniffiTypeRouteAdapterObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(response),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer = uniffiTypeRouteAdapterObjectFactory.pointer(this);
      uniffiTypeRouteAdapterObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RouteAdapter {
    return uniffiTypeRouteAdapterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRouteAdapterObjectFactory: UniffiObjectFactory<RouteAdapterInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): RouteAdapterInterface {
      const instance = Object.create(RouteAdapter.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RouteAdapter';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_routeadapter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: RouteAdapterInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RouteAdapterInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_clone_routeadapter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_free_routeadapter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RouteAdapterInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RouteAdapter'
      );
    },
  };
// FfiConverter for RouteAdapterInterface
const FfiConverterTypeRouteAdapter = new FfiConverterObject(
  uniffiTypeRouteAdapterObjectFactory
);

/**
 * A custom deviation detector (for extending the behavior of [`RouteDeviationTracking`]).
 *
 * This allows for arbitrarily complex implementations when the provided ones are not enough.
 * For example, detecting that the user is proceeding the wrong direction by keeping a ring buffer
 * of recent locations, or perform local map matching.
 */
export interface RouteDeviationDetector {
  /**
   * Determines whether the user is following the route correctly or not.
   *
   * NOTE: This function has a single responsibility.
   * Side-effects like whether to recalculate a route are left to higher levels,
   * and implementations should only be concerned with determining the facts.
   */
  checkRouteDeviation(
    location: UserLocation,
    route: Route,
    currentRouteStep: RouteStep
  ): RouteDeviation;
}

/**
 * A custom deviation detector (for extending the behavior of [`RouteDeviationTracking`]).
 *
 * This allows for arbitrarily complex implementations when the provided ones are not enough.
 * For example, detecting that the user is proceeding the wrong direction by keeping a ring buffer
 * of recent locations, or perform local map matching.
 */
export class RouteDeviationDetectorImpl
  extends UniffiAbstractObject
  implements RouteDeviationDetector
{
  readonly [uniffiTypeNameSymbol] = 'RouteDeviationDetectorImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRouteDeviationDetectorImplObjectFactory.bless(pointer);
  }

  /**
   * Determines whether the user is following the route correctly or not.
   *
   * NOTE: This function has a single responsibility.
   * Side-effects like whether to recalculate a route are left to higher levels,
   * and implementations should only be concerned with determining the facts.
   */
  public checkRouteDeviation(
    location: UserLocation,
    route: Route,
    currentRouteStep: RouteStep
  ): RouteDeviation {
    return FfiConverterTypeRouteDeviation.lift(
      rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_routedeviationdetector_check_route_deviation(
            uniffiTypeRouteDeviationDetectorImplObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeUserLocation.lower(location),
            FfiConverterTypeRoute.lower(route),
            FfiConverterTypeRouteStep.lower(currentRouteStep),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer =
        uniffiTypeRouteDeviationDetectorImplObjectFactory.pointer(this);
      uniffiTypeRouteDeviationDetectorImplObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RouteDeviationDetectorImpl {
    return uniffiTypeRouteDeviationDetectorImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeRouteDeviationDetectorImplObjectFactory: UniffiObjectFactory<RouteDeviationDetector> =
  {
    create(pointer: UnsafeMutableRawPointer): RouteDeviationDetector {
      const instance = Object.create(RouteDeviationDetectorImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RouteDeviationDetectorImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_routedeviationdetector_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: RouteDeviationDetector): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RouteDeviationDetector): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_clone_routedeviationdetector(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_free_routedeviationdetector(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RouteDeviationDetector {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RouteDeviationDetectorImpl'
      );
    },
  };
// FfiConverter for RouteDeviationDetector
const FfiConverterTypeRouteDeviationDetector =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeRouteDeviationDetectorImplObjectFactory
  );

// Add a vtavble for the callbacks that go in RouteDeviationDetector.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRouteDeviationDetector: {
  vtable: UniffiVTableCallbackInterfaceRouteDeviationDetector;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    checkRouteDeviation: (
      uniffiHandle: bigint,
      location: ArrayBuffer,
      route: ArrayBuffer,
      currentRouteStep: ArrayBuffer,
      uniffiOutReturn: UniffiReferenceHolder<ArrayBuffer>,
      uniffiCallStatus: UniffiRustCallStatus
    ) => {
      const uniffiMakeCall = (): RouteDeviation => {
        const jsCallback =
          FfiConverterTypeRouteDeviationDetector.lift(uniffiHandle);
        return jsCallback.checkRouteDeviation(
          FfiConverterTypeUserLocation.lift(location),
          FfiConverterTypeRoute.lift(route),
          FfiConverterTypeRouteStep.lift(currentRouteStep)
        );
      };

      const uniffiWriteReturn = (obj: any) => {
        uniffiOutReturn.pointee = FfiConverterTypeRouteDeviation.lower(obj);
      };
      uniffiTraitInterfaceCall(
        /*callStatus:*/ uniffiCallStatus,
        /*makeCall:*/ uniffiMakeCall,
        /*writeReturn:*/ uniffiWriteReturn,
        /*lowerString:*/ FfiConverterString.lower
      );
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RouteDeviationDetector: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRouteDeviationDetector.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().uniffi_ferrostar_fn_init_callback_vtable_routedeviationdetector(
      uniffiCallbackInterfaceRouteDeviationDetector.vtable
    );
  },
};

/**
 * A trait describing any object capable of generating [`RouteRequest`]s.
 *
 * The interface is intentionally generic. Every routing backend has its own set of
 * parameters, including a "profile," max travel speed, units of speed and distance, and more.
 * It is assumed that these properties will be set at construction time or otherwise configured
 * before use, so that we can keep the public interface as generic as possible.
 *
 * Implementations may be either in Rust (most popular engines should eventually have Rust
 * glue code) or foreign code.
 */
export interface RouteRequestGenerator {
  /**
   * Generates a routing backend request given the set of locations.
   *
   * While most implementations will treat the locations as an ordered sequence, this is not
   * guaranteed (ex: an optimized router).
   */
  generateRequest(
    userLocation: UserLocation,
    waypoints: Array<Waypoint>
  ) /*throws*/ : RouteRequest;
}

/**
 * A trait describing any object capable of generating [`RouteRequest`]s.
 *
 * The interface is intentionally generic. Every routing backend has its own set of
 * parameters, including a "profile," max travel speed, units of speed and distance, and more.
 * It is assumed that these properties will be set at construction time or otherwise configured
 * before use, so that we can keep the public interface as generic as possible.
 *
 * Implementations may be either in Rust (most popular engines should eventually have Rust
 * glue code) or foreign code.
 */
export class RouteRequestGeneratorImpl
  extends UniffiAbstractObject
  implements RouteRequestGenerator
{
  readonly [uniffiTypeNameSymbol] = 'RouteRequestGeneratorImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRouteRequestGeneratorImplObjectFactory.bless(pointer);
  }

  /**
   * Generates a routing backend request given the set of locations.
   *
   * While most implementations will treat the locations as an ordered sequence, this is not
   * guaranteed (ex: an optimized router).
   */
  public generateRequest(
    userLocation: UserLocation,
    waypoints: Array<Waypoint>
  ): RouteRequest /*throws*/ {
    return FfiConverterTypeRouteRequest.lift(
      rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoutingRequestGenerationError.lift.bind(
          FfiConverterTypeRoutingRequestGenerationError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_routerequestgenerator_generate_request(
            uniffiTypeRouteRequestGeneratorImplObjectFactory.clonePointer(this),
            FfiConverterTypeUserLocation.lower(userLocation),
            FfiConverterArrayTypeWaypoint.lower(waypoints),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer =
        uniffiTypeRouteRequestGeneratorImplObjectFactory.pointer(this);
      uniffiTypeRouteRequestGeneratorImplObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RouteRequestGeneratorImpl {
    return uniffiTypeRouteRequestGeneratorImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRouteRequestGeneratorImplObjectFactory: UniffiObjectFactory<RouteRequestGenerator> =
  {
    create(pointer: UnsafeMutableRawPointer): RouteRequestGenerator {
      const instance = Object.create(RouteRequestGeneratorImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RouteRequestGeneratorImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_routerequestgenerator_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: RouteRequestGenerator): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RouteRequestGenerator): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_clone_routerequestgenerator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_free_routerequestgenerator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RouteRequestGenerator {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RouteRequestGeneratorImpl'
      );
    },
  };
// FfiConverter for RouteRequestGenerator
const FfiConverterTypeRouteRequestGenerator =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeRouteRequestGeneratorImplObjectFactory
  );

// Add a vtavble for the callbacks that go in RouteRequestGenerator.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRouteRequestGenerator: {
  vtable: UniffiVTableCallbackInterfaceRouteRequestGenerator;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    generateRequest: (
      uniffiHandle: bigint,
      userLocation: ArrayBuffer,
      waypoints: ArrayBuffer,
      uniffiOutReturn: UniffiReferenceHolder<ArrayBuffer>,
      uniffiCallStatus: UniffiRustCallStatus
    ) => {
      const uniffiMakeCall = (): RouteRequest => {
        const jsCallback =
          FfiConverterTypeRouteRequestGenerator.lift(uniffiHandle);
        return jsCallback.generateRequest(
          FfiConverterTypeUserLocation.lift(userLocation),
          FfiConverterArrayTypeWaypoint.lift(waypoints)
        );
      };

      const uniffiWriteReturn = (obj: any) => {
        uniffiOutReturn.pointee = FfiConverterTypeRouteRequest.lower(obj);
      };
      uniffiTraitInterfaceCallWithError(
        /*callStatus:*/ uniffiCallStatus,
        /*makeCall:*/ uniffiMakeCall,
        /*writeReturn:*/ uniffiWriteReturn,
        /*isErrorType:*/ RoutingRequestGenerationError.instanceOf,
        /*lowerError:*/ FfiConverterTypeRoutingRequestGenerationError.lower.bind(
          FfiConverterTypeRoutingRequestGenerationError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RouteRequestGenerator: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRouteRequestGenerator.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().uniffi_ferrostar_fn_init_callback_vtable_routerequestgenerator(
      uniffiCallbackInterfaceRouteRequestGenerator.vtable
    );
  },
};

/**
 * A generic interface describing any object capable of parsing a response from a routing
 * backend into one or more [`Route`]s.
 */
export interface RouteResponseParser {
  /**
   * Parses a raw response from the routing backend into a route.
   *
   * We use a sequence of octets as a common interchange format.
   * as this works for all currently conceivable formats (JSON, PBF, etc.).
   */
  parseResponse(response: ArrayBuffer) /*throws*/ : Array<Route>;
}

/**
 * A generic interface describing any object capable of parsing a response from a routing
 * backend into one or more [`Route`]s.
 */
export class RouteResponseParserImpl
  extends UniffiAbstractObject
  implements RouteResponseParser
{
  readonly [uniffiTypeNameSymbol] = 'RouteResponseParserImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeRouteResponseParserImplObjectFactory.bless(pointer);
  }

  /**
   * Parses a raw response from the routing backend into a route.
   *
   * We use a sequence of octets as a common interchange format.
   * as this works for all currently conceivable formats (JSON, PBF, etc.).
   */
  public parseResponse(response: ArrayBuffer): Array<Route> /*throws*/ {
    return FfiConverterArrayTypeRoute.lift(
      rustCallWithError(
        /*liftError:*/ FfiConverterTypeParsingError.lift.bind(
          FfiConverterTypeParsingError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().uniffi_ferrostar_fn_method_routeresponseparser_parse_response(
            uniffiTypeRouteResponseParserImplObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(response),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    if ((this as any)[destructorGuardSymbol]) {
      const pointer =
        uniffiTypeRouteResponseParserImplObjectFactory.pointer(this);
      uniffiTypeRouteResponseParserImplObjectFactory.freePointer(pointer);
      this[destructorGuardSymbol].markDestroyed();
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is RouteResponseParserImpl {
    return uniffiTypeRouteResponseParserImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeRouteResponseParserImplObjectFactory: UniffiObjectFactory<RouteResponseParser> =
  {
    create(pointer: UnsafeMutableRawPointer): RouteResponseParser {
      const instance = Object.create(RouteResponseParserImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'RouteResponseParserImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return rustCall(
        /*caller:*/ (status) =>
          nativeModule().uniffi_internal_fn_method_routeresponseparser_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    pointer(obj: RouteResponseParser): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: RouteResponseParser): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_clone_routeresponseparser(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().uniffi_ferrostar_fn_free_routeresponseparser(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is RouteResponseParser {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'RouteResponseParserImpl'
      );
    },
  };
// FfiConverter for RouteResponseParser
const FfiConverterTypeRouteResponseParser = new FfiConverterObjectWithCallbacks(
  uniffiTypeRouteResponseParserImplObjectFactory
);

// Add a vtavble for the callbacks that go in RouteResponseParser.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRouteResponseParser: {
  vtable: UniffiVTableCallbackInterfaceRouteResponseParser;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    parseResponse: (
      uniffiHandle: bigint,
      response: ArrayBuffer,
      uniffiOutReturn: UniffiReferenceHolder<ArrayBuffer>,
      uniffiCallStatus: UniffiRustCallStatus
    ) => {
      const uniffiMakeCall = (): Array<Route> => {
        const jsCallback =
          FfiConverterTypeRouteResponseParser.lift(uniffiHandle);
        return jsCallback.parseResponse(FfiConverterArrayBuffer.lift(response));
      };

      const uniffiWriteReturn = (obj: any) => {
        uniffiOutReturn.pointee = FfiConverterArrayTypeRoute.lower(obj);
      };
      uniffiTraitInterfaceCallWithError(
        /*callStatus:*/ uniffiCallStatus,
        /*makeCall:*/ uniffiMakeCall,
        /*writeReturn:*/ uniffiWriteReturn,
        /*isErrorType:*/ ParsingError.instanceOf,
        /*lowerError:*/ FfiConverterTypeParsingError.lower.bind(
          FfiConverterTypeParsingError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // RouteResponseParser: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeRouteResponseParser.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().uniffi_ferrostar_fn_init_callback_vtable_routeresponseparser(
      uniffiCallbackInterfaceRouteResponseParser.vtable
    );
  },
};

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for BoundingBox | undefined
const FfiConverterOptionalTypeBoundingBox = new FfiConverterOptional(
  FfiConverterTypeBoundingBox
);

// FfiConverter for Congestion | undefined
const FfiConverterOptionalTypeCongestion = new FfiConverterOptional(
  FfiConverterTypeCongestion
);

// FfiConverter for CourseOverGround | undefined
const FfiConverterOptionalTypeCourseOverGround = new FfiConverterOptional(
  FfiConverterTypeCourseOverGround
);

// FfiConverter for Speed | undefined
const FfiConverterOptionalTypeSpeed = new FfiConverterOptional(
  FfiConverterTypeSpeed
);

// FfiConverter for SpokenInstruction | undefined
const FfiConverterOptionalTypeSpokenInstruction = new FfiConverterOptional(
  FfiConverterTypeSpokenInstruction
);

// FfiConverter for VisualInstruction | undefined
const FfiConverterOptionalTypeVisualInstruction = new FfiConverterOptional(
  FfiConverterTypeVisualInstruction
);

// FfiConverter for VisualInstructionContent | undefined
const FfiConverterOptionalTypeVisualInstructionContent =
  new FfiConverterOptional(FfiConverterTypeVisualInstructionContent);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<GeographicCoordinate>
const FfiConverterArrayTypeGeographicCoordinate = new FfiConverterArray(
  FfiConverterTypeGeographicCoordinate
);

// FfiConverter for Array<Incident>
const FfiConverterArrayTypeIncident = new FfiConverterArray(
  FfiConverterTypeIncident
);

// FfiConverter for Array<LaneInfo>
const FfiConverterArrayTypeLaneInfo = new FfiConverterArray(
  FfiConverterTypeLaneInfo
);

// FfiConverter for Array<Route>
const FfiConverterArrayTypeRoute = new FfiConverterArray(FfiConverterTypeRoute);

// FfiConverter for Array<RouteStep>
const FfiConverterArrayTypeRouteStep = new FfiConverterArray(
  FfiConverterTypeRouteStep
);

// FfiConverter for Array<SpokenInstruction>
const FfiConverterArrayTypeSpokenInstruction = new FfiConverterArray(
  FfiConverterTypeSpokenInstruction
);

// FfiConverter for Array<VisualInstruction>
const FfiConverterArrayTypeVisualInstruction = new FfiConverterArray(
  FfiConverterTypeVisualInstruction
);

// FfiConverter for Array<Waypoint>
const FfiConverterArrayTypeWaypoint = new FfiConverterArray(
  FfiConverterTypeWaypoint
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for UtcDateTime | undefined
const FfiConverterOptionalTypeUtcDateTime = new FfiConverterOptional(
  FfiConverterTypeUtcDateTime
);

// FfiConverter for Impact | undefined
const FfiConverterOptionalTypeImpact = new FfiConverterOptional(
  FfiConverterTypeImpact
);

// FfiConverter for ManeuverModifier | undefined
const FfiConverterOptionalTypeManeuverModifier = new FfiConverterOptional(
  FfiConverterTypeManeuverModifier
);

// FfiConverter for ManeuverType | undefined
const FfiConverterOptionalTypeManeuverType = new FfiConverterOptional(
  FfiConverterTypeManeuverType
);

// FfiConverter for SpecialAdvanceConditions | undefined
const FfiConverterOptionalTypeSpecialAdvanceConditions =
  new FfiConverterOptional(FfiConverterTypeSpecialAdvanceConditions);

// FfiConverter for Array<LaneInfo> | undefined
const FfiConverterOptionalArrayTypeLaneInfo = new FfiConverterOptional(
  FfiConverterArrayTypeLaneInfo
);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

// FfiConverter for Array<BlockedLane>
const FfiConverterArrayTypeBlockedLane = new FfiConverterArray(
  FfiConverterTypeBlockedLane
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ffi_ferrostar_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_advance_location_simulation() !==
    26307
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_advance_location_simulation'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_create_ferrostar_logger() !==
    18551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_create_ferrostar_logger'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_create_osrm_response_parser() !==
    16550
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_create_osrm_response_parser'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_create_route_from_osrm() !==
    42270
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_create_route_from_osrm'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_create_valhalla_request_generator() !==
    16275
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_create_valhalla_request_generator'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_get_route_polyline() !== 31480
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_get_route_polyline'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_location_simulation_from_coordinates() !==
    52416
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_location_simulation_from_coordinates'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_location_simulation_from_polyline() !==
    14615
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_location_simulation_from_polyline'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_func_location_simulation_from_route() !==
    39027
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_func_location_simulation_from_route'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_navigationcontroller_advance_to_next_step() !==
    3820
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_navigationcontroller_advance_to_next_step'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_navigationcontroller_get_initial_state() !==
    63862
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_navigationcontroller_get_initial_state'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_navigationcontroller_update_user_location() !==
    3165
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_navigationcontroller_update_user_location'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_routeadapter_generate_request() !==
    59034
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_routeadapter_generate_request'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_routeadapter_parse_response() !==
    34481
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_routeadapter_parse_response'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_routedeviationdetector_check_route_deviation() !==
    50476
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_routedeviationdetector_check_route_deviation'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_routerequestgenerator_generate_request() !==
    63458
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_routerequestgenerator_generate_request'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_method_routeresponseparser_parse_response() !==
    44735
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_method_routeresponseparser_parse_response'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_constructor_navigationcontroller_new() !==
    60881
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_constructor_navigationcontroller_new'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_constructor_routeadapter_new() !==
    32290
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_constructor_routeadapter_new'
    );
  }
  if (
    nativeModule().uniffi_ferrostar_checksum_constructor_routeadapter_new_valhalla_http() !==
    3524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ferrostar_checksum_constructor_routeadapter_new_valhalla_http'
    );
  }

  uniffiCallbackInterfaceRouteDeviationDetector.register();
  uniffiCallbackInterfaceRouteRequestGenerator.register();
  uniffiCallbackInterfaceRouteResponseParser.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBlockedLane,
    FfiConverterTypeBoundingBox,
    FfiConverterTypeCongestion,
    FfiConverterTypeCourseFiltering,
    FfiConverterTypeCourseOverGround,
    FfiConverterTypeGeographicCoordinate,
    FfiConverterTypeHeading,
    FfiConverterTypeImpact,
    FfiConverterTypeIncident,
    FfiConverterTypeIncidentType,
    FfiConverterTypeLaneInfo,
    FfiConverterTypeLocationBias,
    FfiConverterTypeLocationSimulationState,
    FfiConverterTypeManeuverModifier,
    FfiConverterTypeManeuverType,
    FfiConverterTypeNavigationController,
    FfiConverterTypeNavigationControllerConfig,
    FfiConverterTypeRoute,
    FfiConverterTypeRouteAdapter,
    FfiConverterTypeRouteDeviation,
    FfiConverterTypeRouteDeviationDetector,
    FfiConverterTypeRouteDeviationTracking,
    FfiConverterTypeRouteRequest,
    FfiConverterTypeRouteRequestGenerator,
    FfiConverterTypeRouteResponseParser,
    FfiConverterTypeRouteStep,
    FfiConverterTypeSpecialAdvanceConditions,
    FfiConverterTypeSpeed,
    FfiConverterTypeSpokenInstruction,
    FfiConverterTypeStepAdvanceMode,
    FfiConverterTypeTripProgress,
    FfiConverterTypeTripState,
    FfiConverterTypeUserLocation,
    FfiConverterTypeUtcDateTime,
    FfiConverterTypeUuid,
    FfiConverterTypeVisualInstruction,
    FfiConverterTypeVisualInstructionContent,
    FfiConverterTypeWaypoint,
    FfiConverterTypeWaypointKind,
  },
});
